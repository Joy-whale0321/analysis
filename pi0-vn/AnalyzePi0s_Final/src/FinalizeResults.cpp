#include "sPhenixStyle.h"
#include "sPhenixStyle.C"
#include <TFile.h>
#include <TH1F.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <cmath>
/*
This macro does the following:
 --calculates absolute and relative systematic uncertainties from contributions to EMCal Scale variations
 --calculates absolute and relative systematics from contributions to total systematic ucertainty
 --plots final v2 results with total systematic uncertainty
 --plots final v2/v3 results overlay
 --plots v2 as a function of centrality with systematics
 --plots v2 results overlayed with PHENIX 2010 data (calculates estimated PHENIX systematics)
 --plots systematic contributor distributions for both EMCal scale variations and total systematics
 --plots v2 overlays of:
 ------EMCal scale variations
 ------signal bound variations
 ------backgroundw window variations
 ------Asymmetry cut variations
 ------Sample size variations
 ------p013/p015 overlays
 */

struct PlotConfig {
    bool plotSigBgCorrAnd_bgWindowVariations; //plots overlay of signal, bg, corrected v2 for default data, and bg window v2 variation used in syst calc
    bool plotSignalWindowVariations; //plots signal window variation overly v2 values used in systematic calc
    bool plotEMCalScaleVariations; //plots EMCal Scale variation overlay of v2 values used in syst
    bool plotAsymmetryCutVariations; //plots v2 asymmetry comparison
    bool plotSampleSizeVariations; //plots v2 sample size comparison
    bool plotProduction_Comparisons; //plots v2 comparison between p013, p015
};
/*
 Set below booleans to true if have CSVs ready to overlay v2 values
 */
PlotConfig initializePlotConfig() {
    return {
        true,  //signal, bg, corr v2 overlay and background window -- always set true if have default values, only need default CSV
        /*
         The following need additional CSVs prepared -- if want to plot one and can't another, thats what the booleans are used for
         */
        true,  //signal window -- reads in filePathSignal_Bound_Variation
        true,  //plot EMCal scale overlay -- reads in filePathEMCal_Syst_SYST variations
        false,  //plot Asymmetry overlay -- reads in filePath_AsymmetryVariations_45 and filePath_AsymmetryVariations_55
        false,  //plot sample size -- reads filePathSampleSizeVariation
        false   //plot production comparison - reads p013_filePath
    };
}
std::string userPath;
std::string BasePlotOutputPath;
std::string BaseCSVoutput;
std::string ReferenceData;
std::string phenixFilePath;
std::string baseDataPath_ProductionComparisons;
std::string p013_filePath;
std::string filePathEMCal_Syst_SYST1CEMC;
std::string filePathEMCal_Syst_SYST2CEMC;
std::string filePathEMCal_Syst_SYST3DCEMC;
std::string filePathEMCal_Syst_SYST3UCEMC;
std::string filePathEMCal_Syst_SYST4CEMC;
std::string filePath_AsymmetryVariations_45;
std::string filePath_AsymmetryVariations_55;
std::string filePathSampleSizeVariation;
std::string filePathSignal_Bound_Variation;
std::string SystematicsBasePlotOutput;
std::string baseDataPath_EmCal_Systematics;
std::string baseDataPath_AsymmetryCutVariations;
std::string baseDataPath_SampleSizeVariations;
std::string baseDataPath_SignalWindowVariations;
std::string baseDataPath_BackgroundWindowVariations;




//struct to read data from v2 results CSV formatted files, as well as struct holds data of total systematic uncertainties from other file generated by CalculateSyst.cpp
struct Data {
    std::vector<double> corrected_v2_0_20, corrected_v2_0_20_Errors;
    std::vector<double> corrected_v2_20_40, corrected_v2_20_40_Errors;
    std::vector<double> corrected_v2_40_60, corrected_v2_40_60_Errors;
    
    std::vector<double> corrected_v3_0_20, corrected_v3_0_20_Errors;
    std::vector<double> corrected_v3_20_40, corrected_v3_20_40_Errors;
    std::vector<double> corrected_v3_40_60, corrected_v3_40_60_Errors;
    
    std::vector<double> corrected_v2_0_20_type4, corrected_v2_0_20_Errors_type4;
    std::vector<double> corrected_v2_20_40_type4, corrected_v2_20_40_Errors_type4;
    std::vector<double> corrected_v2_40_60_type4, corrected_v2_40_60_Errors_type4;
    
    std::vector<double> signal_v2_0_20, signal_v2_0_20_Errors;
    std::vector<double> signal_v2_20_40, signal_v2_20_40_Errors;
    std::vector<double> signal_v2_40_60, signal_v2_40_60_Errors;
    
    std::vector<double> bg_v2_0_20, bg_v2_0_20_Errors;
    std::vector<double> bg_v2_20_40, bg_v2_20_40_Errors;
    std::vector<double> bg_v2_40_60, bg_v2_40_60_Errors;
    
    std::vector<double> total_syst_uncertainties_0_20, unWeighted_total_syst_uncertainties_40_60; //weighted and unweighted total systematic uncertainty calculated
    std::vector<double> total_syst_uncertainties_20_40, unWeighted_total_syst_uncertainties_20_40;
    std::vector<double> total_syst_uncertainties_40_60, unWeighted_total_syst_uncertainties_0_20;

    /*
     These are all unweighted -- I multiply by abs(v2) value for each respective bin plotted to show absolute contributions
     */
    std::vector<double> quad_sum_EMCal_syst_0_20, signal_window_syst_0_20, background_window_syst_0_20;
    std::vector<double> quad_sum_EMCal_syst_20_40, signal_window_syst_20_40, background_window_syst_20_40;
    std::vector<double> quad_sum_EMCal_syst_40_60, signal_window_syst_40_60, background_window_syst_40_60;
};
/*
 Next two functions are used Read in data from EMCal systematic contributor CSV, both relative and absolute systematic uncertainties
 */
struct EMCal_Systematic_Data { //struct to hold relative and absolute systematic uncertainty contributions to EMCal Scale variations for each centrality
    std::vector<double> RelativeUncertainty_SYST1CEMC_0_20, AbsoluteUncertainty_SYST1CEMC_0_20;
    std::vector<double> RelativeUncertainty_SYST1CEMC_20_40, AbsoluteUncertainty_SYST1CEMC_20_40;
    std::vector<double> RelativeUncertainty_SYST1CEMC_40_60, AbsoluteUncertainty_SYST1CEMC_40_60;
    
    std::vector<double> RelativeUncertainty_SYST2CEMC_0_20, AbsoluteUncertainty_SYST2CEMC_0_20;
    std::vector<double> RelativeUncertainty_SYST2CEMC_20_40, AbsoluteUncertainty_SYST2CEMC_20_40;
    std::vector<double> RelativeUncertainty_SYST2CEMC_40_60, AbsoluteUncertainty_SYST2CEMC_40_60;
    
    std::vector<double> RelativeUncertainty_SYST3DCEMC_0_20, AbsoluteUncertainty_SYST3DCEMC_0_20;
    std::vector<double> RelativeUncertainty_SYST3DCEMC_20_40, AbsoluteUncertainty_SYST3DCEMC_20_40;
    std::vector<double> RelativeUncertainty_SYST3DCEMC_40_60, AbsoluteUncertainty_SYST3DCEMC_40_60;
    
    std::vector<double> RelativeUncertainty_SYST3UCEMC_0_20, AbsoluteUncertainty_SYST3UCEMC_0_20;
    std::vector<double> RelativeUncertainty_SYST3UCEMC_20_40, AbsoluteUncertainty_SYST3UCEMC_20_40;
    std::vector<double> RelativeUncertainty_SYST3UCEMC_40_60, AbsoluteUncertainty_SYST3UCEMC_40_60;
    
    std::vector<double> RelativeUncertainty_SYST4CEMC_0_20, AbsoluteUncertainty_SYST4CEMC_0_20;
    std::vector<double> RelativeUncertainty_SYST4CEMC_20_40, AbsoluteUncertainty_SYST4CEMC_20_40;
    std::vector<double> RelativeUncertainty_SYST4CEMC_40_60, AbsoluteUncertainty_SYST4CEMC_40_60;

    std::vector<double> Relative_QuadSum_0_20, Absolute_QuadSum_0_20;
    std::vector<double> Relative_QuadSum_20_40, Absolute_QuadSum_20_40;
    std::vector<double> Relative_QuadSum_40_60, Absolute_QuadSum_40_60;
};
struct PHENIX_data {
    std::vector<double> v2_0_20_PHENIX, v2_0_20_Errors_PHENIX;
    std::vector<double> v2_20_40_PHENIX, v2_20_40_Errors_PHENIX;
    std::vector<double> v2_40_60_PHENIX, v2_40_60_Errors_PHENIX;
};
//read in v2 values from format of v2 results CSV files
void Read_DataSet(const std::string& filePath, Data& data) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return;
    }
    std::string line;
    std::getline(file, line); // Skip the header line

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::vector<std::string> rowData;
        std::string cell;

        while (std::getline(ss, cell, ',')) {
            rowData.push_back(cell);
        }
        
        double v2_corrected = std::stod(rowData.at(1));
        double v2_error_corrected = std::stod(rowData.at(2));
        
        double v3_corrected = std::stod(rowData.at(5));
        double v3_error_corrected = std::stod(rowData.at(6));
        
        double v2_corrected_type4 = std::stod(rowData.at(3)); //v2 when upper sideband bound is 0.4 instead of default 0.5 GeV
        double v2_error_corrected_type4 = std::stod(rowData.at(4));
        
        double v2_signal = std::stod(rowData.at(7));
        double v2_error_signal = std::stod(rowData.at(8));
        
        double v2_bg = std::stod(rowData.at(9));
        double v2_error_bg = std::stod(rowData.at(10));
        
    
        int index = std::stoi(rowData[0]); //index of analysis bin, first column of CSV
        if (index >= 0 && index <= 5) { //indices 0 through 5 are 40-60% Centrality
            data.corrected_v2_40_60.push_back(v2_corrected);
            data.corrected_v2_40_60_Errors.push_back(v2_error_corrected);
            
            data.corrected_v3_40_60.push_back(v3_corrected);
            data.corrected_v3_40_60_Errors.push_back(v3_error_corrected);
            
            data.corrected_v2_40_60_type4.push_back(v2_corrected_type4);
            data.corrected_v2_40_60_Errors_type4.push_back(v2_error_corrected_type4);
            
            data.signal_v2_40_60.push_back(v2_signal);
            data.signal_v2_40_60_Errors.push_back(v2_error_signal);
            
            data.bg_v2_40_60.push_back(v2_bg);
            data.bg_v2_40_60_Errors.push_back(v2_error_bg);
            
        } else if (index >= 6 && index <= 11) { //indices 6 through 11 are 20-40% Centrality
            data.corrected_v2_20_40.push_back(v2_corrected);
            data.corrected_v2_20_40_Errors.push_back(v2_error_corrected);
            
            data.corrected_v3_20_40.push_back(v3_corrected);
            data.corrected_v3_20_40_Errors.push_back(v3_error_corrected);
            
            data.corrected_v2_20_40_type4.push_back(v2_corrected_type4);
            data.corrected_v2_20_40_Errors_type4.push_back(v2_error_corrected_type4);
            
            data.signal_v2_20_40.push_back(v2_signal);
            data.signal_v2_20_40_Errors.push_back(v2_error_signal);
            
            data.bg_v2_20_40.push_back(v2_bg);
            data.bg_v2_20_40_Errors.push_back(v2_error_bg);
            

        } else if (index >= 12 && index <= 17) { //indices 12 through 17 are 0-20% Centrality
            data.corrected_v2_0_20.push_back(v2_corrected);
            data.corrected_v2_0_20_Errors.push_back(v2_error_corrected);
            
            data.corrected_v3_0_20.push_back(v3_corrected);
            data.corrected_v3_0_20_Errors.push_back(v3_error_corrected);
            
            data.corrected_v2_0_20_type4.push_back(v2_corrected_type4);
            data.corrected_v2_0_20_Errors_type4.push_back(v2_error_corrected_type4);
            
            data.signal_v2_0_20.push_back(v2_signal);
            data.signal_v2_0_20_Errors.push_back(v2_error_signal);
            
            data.bg_v2_0_20.push_back(v2_bg);
            data.bg_v2_0_20_Errors.push_back(v2_error_bg);
            
        }
    }
    file.close();
}
//Writes CSV file for EMCal Scale variations, calculating each contribution to total weighted and unweighted quadrature sum that is funneled into total syst calc
void WriteComparisonTo_EMcalScale_CSV(const std::vector<Data>& emCalDataSets, const Data& referenceData, const std::string& outputPath) {
    std::ofstream outFile(outputPath);
    if (!outFile.is_open()) {
        std::cerr << "Failed to open the file at: " << outputPath << std::endl;
        return;
    }
    outFile << "Index,Reference_v2";
    std::vector<std::string> dataSetLabels = {"SYST1CEMC", "SYST2CEMC", "SYST3DCEMC", "SYST3UCEMC", "SYST4CEMC"}; //used for CSV header writing
    for (const auto& label : dataSetLabels) {
        outFile << ",RelativeUncertainty_" << label << ",AbsoluteUncertainty_" << label;
    }
    // New columns for quadrature sum
    outFile << ",QuadratureSumRelativeUncertainties,QuadratureSumAbsoluteUncertainties\n";

    // Output header for console
    std::cout << "\033[1mCalculating EMCal Systematics:\033[0m\n";
    std::cout << "\033[1m" << std::left << std::setw(15) << "DataSet Label"
              << std::setw(10) << "Index"
              << std::setw(15) << "Reference v2"
              << std::setw(22) << "Abs. Uncertainty" << "\033[0m" << std::endl;
    std::cout << std::string(62, '-') << "\n";
    
    for (size_t index = 0; index < 18; ++index) {
        double sumSquaredRelative = 0.0;
        double sumSquaredAbsolute = 0.0;

        const auto& referenceVector = index < 6 ? referenceData.corrected_v2_40_60 :
                                    index < 12 ? referenceData.corrected_v2_20_40 :
                                    referenceData.corrected_v2_0_20;
        size_t binIndex = index % 6;
        if (binIndex < referenceVector.size()) {
            double reference_v2 = referenceVector[binIndex];
            outFile << index << "," << reference_v2;
            // Starting from index 1 to skip the defaultData at index 0, which is used only as a reference for calculations
            for (size_t dataSetIndex = 1; dataSetIndex < emCalDataSets.size(); ++dataSetIndex) {
                //heres where we grab index 1 of emcaldatasets being SYST1CEMC
                const auto& currentDataSet = emCalDataSets[dataSetIndex];
                const auto& v2_vector = index < 6 ? currentDataSet.corrected_v2_40_60 :
                                        index < 12 ? currentDataSet.corrected_v2_20_40 :
                                        currentDataSet.corrected_v2_0_20;

                if (binIndex < v2_vector.size()) {
                    double v2 = v2_vector[binIndex];
                    double relativeUncertainty = std::abs((v2 - reference_v2) / reference_v2);
                    double absoluteUncertainty = std::abs(v2 - reference_v2);

                    // Squaring the uncertainties for quadrature sum
                    sumSquaredRelative += pow(relativeUncertainty, 2);
                    sumSquaredAbsolute += pow(absoluteUncertainty, 2);

                    outFile << "," << relativeUncertainty << "," << absoluteUncertainty;
                    
                    std::cout << std::left << "\033[1m" << std::setw(15) << dataSetLabels[dataSetIndex-1]
                              << std::setw(10) << index
                              << std::setw(15) << std::fixed << std::setprecision(6) << v2
                              << std::setw(22) << absoluteUncertainty << "\033[0m" << std::endl;
                    
                } else {
                    outFile << ",,"; // In case there's no data for this dataset at this bin index
                    std::cout << std::left << "\033[1m" << std::setw(15) << dataSetLabels[dataSetIndex]
                              << std::setw(10) << index
                              << std::setw(15) << "No Data"
                              << std::setw(22) << "N/A" << "\033[0m" << std::endl;
                }
            }

            // Writing the quadrature sums to the CSV
            outFile << "," << sqrt(sumSquaredRelative) << "," << sqrt(sumSquaredAbsolute);
            outFile << "\n";
        }
    }
    outFile.close();
}
/*
 Writes CSV file for total systematic uncertainty and respective contributors -- signal window, background window (read in as corrected_v2_type4), and EMCal Scale Variations
 */
void WriteComparisonToCSV(const std::vector<Data>& emCalDataSets, const Data& signalWindowData, const Data& referenceData, const std::string& outputPath) {
    std::ofstream outFile(outputPath);
    outFile << "Index,Reference_v2,Quad_Sum_EMCal_Syst,SignalWindow_Syst,BackgroundWindow_Syst,WeightedQuadratureSum,unWeightedQuadratureSum\n";
    
    
    // Header for terminal output with ANSI color codes for red font
    std::cout << "\033[1;31m"; // Red color start
    std::cout << std::left << std::setw(10) << "Index" << std::setw(20) << "Reference v2"
              << std::setw(20) << "Final Quad Sum" << "\n";
    std::cout << "\033[0m"; // Reset to default color

    bool skipNextDataSet = false; // Renamed for clarity
    for (size_t index = 0; index < 18; ++index) {
        const auto& referenceVector = index < 6 ? referenceData.corrected_v2_40_60 :
                                    index < 12 ? referenceData.corrected_v2_20_40 :
                                    referenceData.corrected_v2_0_20;
        size_t binIndex = index % 6;
        double reference_v2 = referenceVector[binIndex];
        double quadratureSum = 0.0;
        
        // Calculate quadrature sum for EMCal systematics datasets
        for (size_t dataSetIndex = 1; dataSetIndex < emCalDataSets.size(); ++dataSetIndex) {
            const auto& v2_vector = index < 6 ? emCalDataSets[dataSetIndex].corrected_v2_40_60 :
                                  index < 12 ? emCalDataSets[dataSetIndex].corrected_v2_20_40 :
                                  emCalDataSets[dataSetIndex].corrected_v2_0_20;
            double v2 = v2_vector[binIndex];
            double relativeDifference = std::abs((v2 - reference_v2) / reference_v2);
            
            if (dataSetIndex == 3 || dataSetIndex == 4) { // Special handling for the two datasets
                const auto& other_v2_vector = index < 6 ? emCalDataSets[4].corrected_v2_40_60 :
                                              index < 12 ? emCalDataSets[4].corrected_v2_20_40 :
                                              emCalDataSets[4].corrected_v2_0_20;
                double other_v2 = other_v2_vector[binIndex];
                double otherRelativeDifference = std::abs((other_v2 - reference_v2) / reference_v2);
                
                if (dataSetIndex == 3) {
                    relativeDifference = std::max(relativeDifference, otherRelativeDifference);
                    dataSetIndex++; // Skip the next dataset as it is already compared
                }
            }

            quadratureSum += std::pow(relativeDifference, 2);
        }

        double finalQuadratureSum = std::sqrt(quadratureSum);

        // Calculate relative difference for the signal window dataset
        double signalWindow_v2 = 0.0, signalWindowRelativeDifference = 0.0;
        if (signalWindowData.corrected_v2_0_20.size() > binIndex) { // Ensure there's data to compare
            const auto& signalWindowVector = index < 6 ? signalWindowData.corrected_v2_40_60 :
                                          index < 12 ? signalWindowData.corrected_v2_20_40 :
                                          signalWindowData.corrected_v2_0_20;
            signalWindow_v2 = signalWindowVector[binIndex];
            signalWindowRelativeDifference = std::abs((reference_v2 - signalWindow_v2) / reference_v2);
        }

        // Calculate relative difference for Type4 within the same dataset
        double type4_v2 = 0.0, type4RelativeDifference = 0.0;
        if (referenceData.corrected_v2_0_20_type4.size() > binIndex) {
            const auto& type4Vector = index < 6 ? referenceData.corrected_v2_40_60_type4 :
                                  index < 12 ? referenceData.corrected_v2_20_40_type4 :
                                  referenceData.corrected_v2_0_20_type4;
            type4_v2 = type4Vector[binIndex];
            type4RelativeDifference = std::abs((reference_v2 - type4_v2) / reference_v2);
        }

        // Calculate the weighted quadrature sum
        double weightedQuadratureSum = std::abs(reference_v2)* std::sqrt(
            std::pow(finalQuadratureSum, 2) +
            std::pow(signalWindowRelativeDifference, 2) +
            std::pow(type4RelativeDifference, 2)
        );
        
        // Calculate the weighted quadrature sum
        double QuadratureSum_Unweighted = std::sqrt(
            std::pow(finalQuadratureSum, 2) +
            std::pow(signalWindowRelativeDifference, 2) +
            std::pow(type4RelativeDifference, 2)
        );


        outFile << index << "," << reference_v2 << "," << finalQuadratureSum << ","
                << signalWindowRelativeDifference << "," << type4RelativeDifference << "," << weightedQuadratureSum << "," << QuadratureSum_Unweighted << "\n";
    }
    
    outFile.close();
}
/*
 read CSV with total systematic uncertainties (relative values) and quad sum of weighted systematic uncertainty, as well as quad sum of unweighted syst
 */
void ReadStatUncertainties(const std::string& filePath, Data& data) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return;
    }
    std::string line;
    std::getline(file, line); // Skip the header line

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::vector<std::string> rowData;
        std::string cell;

        while (std::getline(ss, cell, ',')) {
            rowData.push_back(cell);
        }
        
        double syst_uncertainty = std::stod(rowData.at(5));
        double unWeighted_syst_uncertainty = std::stod(rowData.at(6));
        double quad_sum_EMCal_syst = std::stod(rowData.at(2)); // Quad_Sum_EMCal_Syst
        double signal_window_syst = std::stod(rowData.at(3));  // SignalWindow_Syst
        double background_window_syst = std::stod(rowData.at(4)); // BackgroundWindow_Syst
        
    
        int index = std::stoi(rowData[0]);
        if (index >= 0 && index <= 5) {
            data.total_syst_uncertainties_40_60.push_back(syst_uncertainty);
            data.unWeighted_total_syst_uncertainties_40_60.push_back(unWeighted_syst_uncertainty);
            data.quad_sum_EMCal_syst_40_60.push_back(quad_sum_EMCal_syst);
            data.signal_window_syst_40_60.push_back(signal_window_syst);
            data.background_window_syst_40_60.push_back(background_window_syst);
            
            
        } else if (index >= 6 && index <= 11) {
            data.total_syst_uncertainties_20_40.push_back(syst_uncertainty);
            data.unWeighted_total_syst_uncertainties_20_40.push_back(unWeighted_syst_uncertainty);
            data.quad_sum_EMCal_syst_20_40.push_back(quad_sum_EMCal_syst);
            data.signal_window_syst_20_40.push_back(signal_window_syst);
            data.background_window_syst_20_40.push_back(background_window_syst);

        } else if (index >= 12 && index <= 17) {
            data.total_syst_uncertainties_0_20.push_back(syst_uncertainty);
            data.unWeighted_total_syst_uncertainties_0_20.push_back(unWeighted_syst_uncertainty);
            data.quad_sum_EMCal_syst_0_20.push_back(quad_sum_EMCal_syst);
            data.signal_window_syst_0_20.push_back(signal_window_syst);
            data.background_window_syst_0_20.push_back(background_window_syst);
        }
    }
    file.close();

}
//function that reads in systematic uncertainties from EMCal syst contributor CSV file generated from CalculateSystematics.cpp
void ReadStatUncertainties_emCalScaleCSV(const std::string& filePath, EMCal_Systematic_Data& EMCal_Systematic_Data) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << filePath << std::endl;
        return;
    }
    std::string line;
    std::getline(file, line); // Skip the header line
    
    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::vector<std::string> rowData;
        std::string cell;
        
        while (std::getline(ss, cell, ',')) {
            rowData.push_back(cell);
        }
        
        double relativeUncertainty_SYST1CEMC = std::stod(rowData.at(2));
        double absoluteUncertainty_SYST1CEMC = std::stod(rowData.at(3));
        
        double relativeUncertainty_SYST2CEMC = std::stod(rowData.at(4));
        double absoluteUncertainty_SYST2CEMC = std::stod(rowData.at(5));
        
        double relativeUncertainty_SYST3DCEMC = std::stod(rowData.at(6));
        double absoluteUncertainty_SYST3DCEMC = std::stod(rowData.at(7));
        
        double relativeUncertainty_SYST3UCEMC = std::stod(rowData.at(8));
        double absoluteUncertainty_SYST3UCEMC = std::stod(rowData.at(9));
        
        double relativeUncertainty_SYST4CEMC = std::stod(rowData.at(10));
        double absoluteUncertainty_SYST4CEMC = std::stod(rowData.at(11));
        
        double relative_QuadSum = std::stod(rowData.at(12));
        double Absolute_QuadSum = std::stod(rowData.at(13));

        
        
        int index = std::stoi(rowData[0]);
        if (index >= 0 && index <= 5) {
            EMCal_Systematic_Data.RelativeUncertainty_SYST1CEMC_40_60.push_back(relativeUncertainty_SYST1CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST1CEMC_40_60.push_back(absoluteUncertainty_SYST1CEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST2CEMC_40_60.push_back(relativeUncertainty_SYST2CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST2CEMC_40_60.push_back(absoluteUncertainty_SYST2CEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST3DCEMC_40_60.push_back(relativeUncertainty_SYST3DCEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST3DCEMC_40_60.push_back(absoluteUncertainty_SYST3DCEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST3UCEMC_40_60.push_back(relativeUncertainty_SYST3UCEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST3UCEMC_40_60.push_back(absoluteUncertainty_SYST3UCEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST4CEMC_40_60.push_back(relativeUncertainty_SYST4CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST4CEMC_40_60.push_back(absoluteUncertainty_SYST4CEMC);
            
            EMCal_Systematic_Data.Relative_QuadSum_40_60.push_back(relative_QuadSum);
            EMCal_Systematic_Data.Absolute_QuadSum_40_60.push_back(Absolute_QuadSum);
            
            
        } else if (index >= 6 && index <= 11) {
            EMCal_Systematic_Data.RelativeUncertainty_SYST1CEMC_20_40.push_back(relativeUncertainty_SYST1CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST1CEMC_20_40.push_back(absoluteUncertainty_SYST1CEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST2CEMC_20_40.push_back(relativeUncertainty_SYST2CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST2CEMC_20_40.push_back(absoluteUncertainty_SYST2CEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST3DCEMC_20_40.push_back(relativeUncertainty_SYST3DCEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST3DCEMC_20_40.push_back(absoluteUncertainty_SYST3DCEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST3UCEMC_20_40.push_back(relativeUncertainty_SYST3UCEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST3UCEMC_20_40.push_back(absoluteUncertainty_SYST3UCEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST4CEMC_20_40.push_back(relativeUncertainty_SYST4CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST4CEMC_20_40.push_back(absoluteUncertainty_SYST4CEMC);
            
            EMCal_Systematic_Data.Relative_QuadSum_20_40.push_back(relative_QuadSum);
            EMCal_Systematic_Data.Absolute_QuadSum_20_40.push_back(Absolute_QuadSum);
            
        } else if (index >= 12 && index <= 17) {
            EMCal_Systematic_Data.RelativeUncertainty_SYST1CEMC_0_20.push_back(relativeUncertainty_SYST1CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST1CEMC_0_20.push_back(absoluteUncertainty_SYST1CEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST2CEMC_0_20.push_back(relativeUncertainty_SYST2CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST2CEMC_0_20.push_back(absoluteUncertainty_SYST2CEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST3DCEMC_0_20.push_back(relativeUncertainty_SYST3DCEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST3DCEMC_0_20.push_back(absoluteUncertainty_SYST3DCEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST3UCEMC_0_20.push_back(relativeUncertainty_SYST3UCEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST3UCEMC_0_20.push_back(absoluteUncertainty_SYST3UCEMC);
            
            EMCal_Systematic_Data.RelativeUncertainty_SYST4CEMC_0_20.push_back(relativeUncertainty_SYST4CEMC);
            EMCal_Systematic_Data.AbsoluteUncertainty_SYST4CEMC_0_20.push_back(absoluteUncertainty_SYST4CEMC);
            
            EMCal_Systematic_Data.Relative_QuadSum_0_20.push_back(relative_QuadSum);
            EMCal_Systematic_Data.Absolute_QuadSum_0_20.push_back(Absolute_QuadSum);
            
        }
    }
    file.close();
    
}
void ReadPHENIXData(std::string filePath,
                    std::vector<double>& v2_0_10,
                    std::vector<double>& v2_0_10_Errors,
                    std::vector<double>& v2_0_10_Errors_Negative,
                    std::vector<double>& v2_10_20,
                    std::vector<double>& v2_10_20_Errors,
                    std::vector<double>& v2_10_20_Errors_Negative,
                    std::vector<double>& v2_20_30,
                    std::vector<double>& v2_20_30_Errors,
                    std::vector<double>& v2_20_30_Errors_Negative,
                    std::vector<double>& v2_30_40,
                    std::vector<double>& v2_30_40_Errors,
                    std::vector<double>& v2_30_40_Errors_Negative,
                    std::vector<double>& v2_40_50,
                    std::vector<double>& v2_40_50_Errors,
                    std::vector<double>& v2_40_50_Errors_Negative,
                    std::vector<double>& v2_50_60,
                    std::vector<double>& v2_50_60_Errors,
                    std::vector<double>& v2_50_60_Errors_Negative) {
    std::ifstream file(filePath);
    std::string line;
    double v2, error_pos, error_neg;
    int rowCounter = 0;
    // Skip the header line
    std::getline(file, line);
    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string cell;
        std::vector<std::string> rowData;
        while (std::getline(ss, cell, ',')) {
            rowData.push_back(cell);
        }
        v2 = std::stod(rowData.at(2));
        error_pos = std::stod(rowData.at(rowData.size() - 2)); // stat. +
        error_neg = std::stod(rowData.back()); // stat. -
        // Assigning to the correct centrality vector based on row count in my specific cleaned PHENIX data CSV
        if (rowCounter < 6) { // 0-10%
            v2_0_10.push_back(v2);
            v2_0_10_Errors.push_back(error_pos);
            v2_0_10_Errors_Negative.push_back(fabs(error_neg));
            std::cout << "\033[1mData read in for PHENIX v2_0_10:\033[0m " << v2 << " \u00B1 " << error_pos << std::endl;
        } else if (rowCounter < 12) { // 10-20%
            v2_10_20.push_back(v2);
            v2_10_20_Errors.push_back(error_pos);
            v2_10_20_Errors_Negative.push_back(fabs(error_neg));
            std::cout << "\033[1mData read in for PHENIX v2_10_20:\033[0m " << v2 << " \u00B1 " << error_pos << std::endl;
        } else if (rowCounter < 18) { // 20-30%
            v2_20_30.push_back(v2);
            v2_20_30_Errors.push_back(error_pos);
            v2_20_30_Errors_Negative.push_back(fabs(error_neg));
            std::cout << "\033[1mData read in for PHENIX v2_20_30:\033[0m " << v2 << " \u00B1 " << error_pos << std::endl;
        } else if (rowCounter < 24) { // 30-40%
            v2_30_40.push_back(v2);
            v2_30_40_Errors.push_back(error_pos);
            v2_30_40_Errors_Negative.push_back(fabs(error_neg));
            std::cout << "\033[1mData read in for PHENIX v2_30_40:\033[0m " << v2 << " \u00B1 " << error_pos << std::endl;
        } else if (rowCounter < 30) { // 40-50%
            v2_40_50.push_back(v2);
            v2_40_50_Errors.push_back(error_pos);
            v2_40_50_Errors_Negative.push_back(fabs(error_neg));
            std::cout << "\033[1mData read in for PHENIX v2_40_50:\033[0m " << v2 << " \u00B1 " << error_pos << std::endl;
        } else { // 50-60%
            v2_50_60.push_back(v2);
            v2_50_60_Errors.push_back(error_pos);
            v2_50_60_Errors_Negative.push_back(fabs(error_neg));
            std::cout << "\033[1mData read in for PHENIX v2_50_60:\033[0m " << v2 << " \u00B1 " << error_pos << std::endl;
        }
        rowCounter++;
    }
    file.close();
}
void CombineCentralityData(const std::vector<double>& v2_0_10, const std::vector<double>& v2_0_10_Errors,
                           const std::vector<double>& v2_10_20, const std::vector<double>& v2_10_20_Errors,
                           std::vector<double>& v2_0_20_PHENIX, std::vector<double>& v2_0_20_Errors_PHENIX,
                           const std::vector<double>& v2_20_30, const std::vector<double>& v2_20_30_Errors,
                           const std::vector<double>& v2_30_40, const std::vector<double>& v2_30_40_Errors,
                           std::vector<double>& v2_20_40_PHENIX, std::vector<double>& v2_20_40_Errors_PHENIX,
                           const std::vector<double>& v2_40_50, const std::vector<double>& v2_40_50_Errors,
                           const std::vector<double>& v2_50_60, const std::vector<double>& v2_50_60_Errors,
                           std::vector<double>& v2_40_60_PHENIX, std::vector<double>& v2_40_60_Errors_PHENIX) {
    for (size_t i = 0; i < v2_0_10.size(); ++i) {
        // Compute average v2
        double avg_v2 = (v2_0_10[i] + v2_10_20[i]) / 2.0;
        v2_0_20_PHENIX.push_back(avg_v2);

        double combined_error = sqrt(pow(v2_0_10_Errors[i], 2) + pow(v2_10_20_Errors[i], 2)) / 2.0;
        v2_0_20_Errors_PHENIX.push_back(combined_error);
    }
    for (size_t i = 0; i < v2_20_30.size(); ++i) {
        double avg_v2_20_40 = (v2_20_30[i] + v2_30_40[i]) / 2.0;
        v2_20_40_PHENIX.push_back(avg_v2_20_40);
        double combined_error_20_40 = sqrt(pow(v2_20_30_Errors[i], 2) + pow(v2_30_40_Errors[i], 2)) / 2.0;
        v2_20_40_Errors_PHENIX.push_back(combined_error_20_40);
    }
    for (size_t i = 0; i < v2_40_50.size(); ++i) {
        double avg_v2_40_60 = (v2_40_50[i] + v2_50_60[i]) / 2.0;
        v2_40_60_PHENIX.push_back(avg_v2_40_60);
        double combined_error_40_60 = sqrt(pow(v2_40_50_Errors[i], 2) + pow(v2_50_60_Errors[i], 2)) / 2.0;
        v2_40_60_Errors_PHENIX.push_back(combined_error_40_60);
    }
}
std::vector<double> CalculatePHENIXsystematicError(const std::vector<double>& data, double sigma_RP, double v2_raw_syst) {
    std::vector<double> systematicErrors;
    for (const auto& value : data) {
        double sigma_RP_error = value * sigma_RP;  // Use the multiplier directly dependent on centrality
        double v2_raw_error = value * v2_raw_syst;  // Use the multiplier directly dependent on centrality
        double total_systematic_error = std::sqrt(sigma_RP_error * sigma_RP_error + v2_raw_error * v2_raw_error);
        systematicErrors.push_back(total_systematic_error);
    }
    return systematicErrors;
}
// Function to create and return a TGraphErrors pointer
TGraphErrors* CreateGraph(const std::vector<double>& ptCenters, const std::vector<double>& values, const std::vector<double>& errors) {
    return new TGraphErrors(ptCenters.size(), &ptCenters[0], &values[0], nullptr, &errors[0]);
}
// Function to create and return a TGraphAsymmErrors pointer
TGraphErrors* CreateSystematicGraph(const std::vector<double>& ptCenters,
                                    const std::vector<double>& values,
                                    const std::vector<double>& statErrors,
                                    const std::vector<double>& sysErrors) {

    std::vector<double> sysx(ptCenters.size(), 0.05);
    auto* graph = new TGraphErrors(ptCenters.size(), &ptCenters[0], &values[0], &sysx[0], &sysErrors[0]);
    
    graph->SetFillColorAlpha(kRed, 0.35); //just set as place holder
    
    return graph;
}

void DrawZeroLine(TCanvas* canvas) {
    if (!canvas) return;
    canvas->Update();
    double x_min = canvas->GetUxmin(); // Get the minimum x-value from the canvas
    double x_max = canvas->GetUxmax(); // Get the maximum x-value from the canvas
    // Create and draw a dashed line at y = 0
    TLine* zeroLine = new TLine(x_min, 0, x_max, 0);
    zeroLine->SetLineStyle(2);
    zeroLine->Draw("SAME");
    canvas->Modified();
    canvas->Update();
}
void Create_sPHENIX_legend(TCanvas* canvas, float x1, float y1, float x2, float y2, const std::string& centrality, float textSize) {
    if (!canvas) return; // Check if canvas is valid
    canvas->cd(); // Switch to the canvas context
    TLegend *leg = new TLegend(x1, y1, x2, y2);
    leg->SetFillStyle(0);
    leg->SetTextSize(textSize);
    leg->AddEntry("", "#it{#bf{sPHENIX}} Internal", "");
    leg->AddEntry("", "Au+Au #sqrt{s_{NN}} = 200 GeV", "");
    leg->AddEntry("", centrality.c_str(), "");
    leg->Draw("same");
}
void Create_sPHENIX_legend_Results(TCanvas* canvas, float x1, float y1, float x2, float y2, const std::string& centrality, float textSize) {
    if (!canvas) return; // Check if canvas is valid
    canvas->cd(); // Switch to the canvas context
    TLegend *leg = new TLegend(x1, y1, x2, y2);
    leg->SetFillStyle(0);
    leg->SetTextSize(textSize);
    leg->AddEntry("", "#it{#bf{sPHENIX}} Internal", "");
    leg->AddEntry("", "Au+Au #sqrt{s_{NN}} = 200 GeV", "");
    leg->AddEntry("", "Build: ana412, Production: 2023p015", "");
    leg->AddEntry("", centrality.c_str(), "");
    leg->Draw("same");
}
// Next 3 Functions are for printing of sPHENIX and PHENIX v2 values and syst/stat error
void printTableHeader() {
    std::cout << "\033[1m"  // Bold text
              << std::left
              << std::setw(15) << "Centrality"
              << std::setw(10) << "pT (GeV)"
              << std::setw(15) << "v2 Value"
              << std::setw(20) << "Stat. Error"
              << std::setw(20) << "Syst. Error"
              << "\033[0m\n"; // Reset formatting
    std::cout << std::string(80, '-') << std::endl;
}
void printDataRow(const std::string& centrality, double pt, double value, double statError, double systError) {
    std::cout << "\033[1m"
              << std::setw(15) << centrality
              << "\033[0m"
              << std::fixed << std::setprecision(4)
              << std::setw(10) << pt
              << std::setw(15) << value
              << std::setw(20) << statError
              << std::setw(20) << systError << std::endl;
}

// Function to print graph data
void printGraphData(const std::string& centrality, TGraphErrors* statGraph, TGraphErrors* systGraph) {
    printTableHeader();
    for (int i = 0; i < statGraph->GetN(); ++i) {
        double pt = statGraph->GetX()[i];
        double value = statGraph->GetY()[i];
        double statError = statGraph->GetEY()[i];
        double systError = systGraph ? systGraph->GetEY()[i] : 0; // Handle case when systGraph might be nullptr
        printDataRow(centrality, pt, value, statError, systError);
    }
}
std::vector<double> ptCenters = {2.25, 2.75, 3.25, 3.75, 4.25, 4.75}; // Mid-points of pT ranges for plots
std::vector<std::string> centralityLabels = {"0-20%", "20-40%", "40-60%"};
double offset = 0.05; //used to jitter overlayed points within a pT bin to not overlap
double minYaxis = -0.3;
double maxYaxis = 0.5;

struct GraphProperties {
    int markerColor;
    int markerStyle;
    double markerSize;
};
void setGraphProperties(TGraph* graph, int markerColor, int lineColor, float markerSize, int markerStyle) {
    graph->SetMarkerColor(markerColor);
    graph->SetLineColor(lineColor);
    graph->SetMarkerSize(markerSize);
    graph->SetMarkerStyle(markerStyle);
}

void plotting_Results_andPHENIXoverlay(const Data& data1) {
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v3_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v3_0_20, data1.corrected_v3_0_20_Errors);
    TGraphErrors* corrected_v3_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v3_20_40, data1.corrected_v3_20_40_Errors);
    TGraphErrors* corrected_v3_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v3_40_60, data1.corrected_v3_40_60_Errors);
    
    TGraphErrors* sys_v2_0_20_graph_1 = CreateSystematicGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors, data1.total_syst_uncertainties_0_20);
    TGraphErrors* sys_v2_20_40_graph_1 = CreateSystematicGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors, data1.total_syst_uncertainties_20_40);
    TGraphErrors* sys_v2_40_60_graph_1 = CreateSystematicGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors, data1.total_syst_uncertainties_40_60);
    
    printGraphData("0-20%", corrected_v2_0_20_graph_1, sys_v2_0_20_graph_1);
    printGraphData("20-40%", corrected_v2_20_40_graph_1, sys_v2_20_40_graph_1);
    printGraphData("40-60%", corrected_v2_40_60_graph_1, sys_v2_40_60_graph_1);
    
    setGraphProperties(corrected_v2_0_20_graph_1, kBlack, kBlack, 1.0, 20);
    setGraphProperties(corrected_v2_20_40_graph_1, kBlack, kBlack, 1.0, 20);
    setGraphProperties(corrected_v2_40_60_graph_1, kBlack, kBlack, 1.0, 20);
    
    setGraphProperties(corrected_v3_0_20_graph_1, kBlue, kBlue, 1.0, 20);
    setGraphProperties(corrected_v3_20_40_graph_1, kBlue, kBlue, 1.0, 20);
    setGraphProperties(corrected_v3_40_60_graph_1, kBlue, kBlue, 1.0, 20);
    
    sys_v2_0_20_graph_1->SetFillColor(kGray+1); // Gray color
    sys_v2_0_20_graph_1->SetFillStyle(3001); // Semi-transparent fill
    
    sys_v2_20_40_graph_1->SetFillColor(kGray+1);
    sys_v2_20_40_graph_1->SetFillStyle(3001);

    sys_v2_40_60_graph_1->SetFillColor(kGray+1);
    sys_v2_40_60_graph_1->SetFillStyle(3001);
    
    /*
    FINAL RESULTS WITH SYSTEMATIC UNCERTAINTY, helper function to minimize repeat code, I do this throughout macro
    */
    auto create_sPHENIX_Results = [&data1](TCanvas* canvas, TGraphErrors* graph1, TGraphErrors* graph2,  const std::string& centrality) {
        graph1->Draw("A2"); // Draw systematic errors first as a shaded area
        graph2->Draw("P SAME"); // Then draw the statistical errors on top
        graph1->GetXaxis()->SetTitle("p_{T} [GeV]");
        graph1->GetYaxis()->SetTitle("v_{2}^{#pi^{0}}");
        graph1->SetMinimum(minYaxis); // Set the minimum y value
        graph1->SetMaximum(maxYaxis); // Set the maximum y value
        graph1->GetXaxis()->SetLimits(2.0, 5.0);
        DrawZeroLine(canvas);
        Create_sPHENIX_legend_Results(canvas, 0.14, 0.19, 0.34, 0.44, centrality.c_str(), 0.045);
    };
    TCanvas *c_Overlay_1_finalResults = new TCanvas("c_Overlay_1_finalResults", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    create_sPHENIX_Results(c_Overlay_1_finalResults, sys_v2_0_20_graph_1, corrected_v2_0_20_graph_1, "0-20% Centrality");
    c_Overlay_1_finalResults->SaveAs((BasePlotOutputPath + "/v2_FinalResults/Corrected_v2_0_20.png").c_str());
    
    TCanvas *c_Overlay_2_finalResults = new TCanvas("c_Overlay_2_finalResults", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    create_sPHENIX_Results(c_Overlay_2_finalResults, sys_v2_20_40_graph_1, corrected_v2_20_40_graph_1, "20-40% Centrality");
    c_Overlay_2_finalResults->SaveAs((BasePlotOutputPath + "/v2_FinalResults/Corrected_v2_20_40.png").c_str());
    
    TCanvas *c_Overlay_3_finalResults = new TCanvas("c_Overlay_3_finalResults", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    create_sPHENIX_Results(c_Overlay_3_finalResults, sys_v2_40_60_graph_1, corrected_v2_40_60_graph_1, "40-60% Centrality");
    c_Overlay_3_finalResults->SaveAs((BasePlotOutputPath + "/v2_FinalResults/Corrected_v2_40_60.png").c_str());
    
    for (int i = 0; i < ptCenters.size(); ++i) {
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] - .05, data1.corrected_v2_0_20[i]);
        corrected_v3_0_20_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v3_0_20[i]);
        
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] - .05, data1.corrected_v2_20_40[i]);
        corrected_v3_20_40_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v3_20_40[i]);
        
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] - .05, data1.corrected_v2_40_60[i]);
        corrected_v3_40_60_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v3_40_60[i]);

    }
    
    //plot v3 versus pT
    auto create_v3_graphs = [&data1](TCanvas* canvas, TGraphErrors* graph1, TGraphErrors* graph2, const std::string& centrality) {
        graph1->Draw("AP"); // Draw systematic errors first as a shaded area
        graph2->Draw("P SAME");
        graph1->GetXaxis()->SetTitle("p_{T} [GeV]");
        graph1->GetYaxis()->SetTitle("v_{N}^{#pi^{0}}");
        graph1->SetMinimum(-2.5); // Set the minimum y value
        graph1->SetMaximum(3); // Set the maximum y value
        graph1->GetXaxis()->SetLimits(2.0, 5.0);
        DrawZeroLine(canvas);
        Create_sPHENIX_legend(canvas, 0.14, 0.8, 0.34, 0.92, centrality.c_str(), 0.038);
        TLegend *leg = new TLegend(0.2,.2,0.4,.4);
        leg->SetTextSize(0.029);
        leg->AddEntry(graph1, "v_{2}^{#pi^{0}}", "pe");
        leg->AddEntry(graph2, "v_{3}^{#pi^{0}}", "pe");
        leg->Draw("same");
    };
    TCanvas *c_Overlay_v3_0_20 = new TCanvas("c_Overlay_v3_0_20", "#pi^{0} #it{v}_{3} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    create_v3_graphs(c_Overlay_v3_0_20, corrected_v2_0_20_graph_1, corrected_v3_0_20_graph_1, "0-20% Centrality");
    c_Overlay_v3_0_20->SaveAs((BasePlotOutputPath + "/v3_FinalResults/Corrected_vN_0_20.png").c_str());
    
    TCanvas *c_Overlay_v3_20_40 = new TCanvas("c_Overlay_v3_20_40", "#pi^{0} #it{v}_{3} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    create_v3_graphs(c_Overlay_v3_20_40, corrected_v2_20_40_graph_1, corrected_v3_20_40_graph_1, "20-40% Centrality");
    c_Overlay_v3_20_40->SaveAs((BasePlotOutputPath + "/v3_FinalResults/Corrected_vN_20_40.png").c_str());
    
    TCanvas *c_Overlay_v3_40_60 = new TCanvas("c_Overlay_v3_40_60", "#pi^{0} #it{v}_{3} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    create_v3_graphs(c_Overlay_v3_40_60, corrected_v2_40_60_graph_1, corrected_v3_40_60_graph_1, "40-60% Centrality");
    c_Overlay_v3_40_60->SaveAs((BasePlotOutputPath + "/v3_FinalResults/Corrected_vN_40_60.png").c_str());
    

    // Define centrality bins and their labels
    const int nCentralityBins = 3;
    const char* centralityLabels[nCentralityBins] = {"0-20%", "20-40%", "40-60%"};
    double centralityPositions[nCentralityBins] = {1, 2, 3}; // Position on the x-axis for each category

    const int nPtBins = 6;
    double ptOffsets[nPtBins] = {-0.3, -0.18, -0.06, 0.06, 0.18, 0.3}; // Offset for each pt bin within the centrality category

    TCanvas* c_fun_of_centrality = new TCanvas("c", "v2 vs Centrality", 800, 600);
    TMultiGraph* mgAll = new TMultiGraph();
    
    TLegend* legend = new TLegend(0.3, 0.72, 0.6, 0.92);
    legend->SetTextSize(0.026);
    legend->SetNColumns(2);

    const char* ptBinLabels[nPtBins] = {
        "2.0 #leq p_{T} < 2.5",
        "2.5 #leq p_{T} < 3.0",
        "3.0 #leq p_{T} < 3.5",
        "3.5 #leq p_{T} < 4.0",
        "4.0 #leq p_{T} < 4.5",
        "4.5 #leq p_{T} < 5.0"
    };


    int colors[nPtBins] = {kRed, kBlue, kBlack, kViolet, kGreen+1, kOrange+7};
    int markers[nPtBins] = {20, 20, 20, 20, 20, 20};
    
    for (int iPt = 0; iPt < nPtBins; iPt++) {
        double v2Values[nCentralityBins] = {data1.corrected_v2_0_20[iPt], data1.corrected_v2_20_40[iPt], data1.corrected_v2_40_60[iPt]};
        double v2Errors[nCentralityBins] = {data1.corrected_v2_0_20_Errors[iPt], data1.corrected_v2_20_40_Errors[iPt], data1.corrected_v2_40_60_Errors[iPt]};
        double Systematics[nCentralityBins] = {data1.total_syst_uncertainties_0_20[iPt], data1.total_syst_uncertainties_20_40[iPt], data1.total_syst_uncertainties_40_60[iPt]};

        TGraphAsymmErrors* grSyst = new TGraphAsymmErrors(nCentralityBins);
        TGraphErrors* grStat = new TGraphErrors(nCentralityBins);

        for (int iCent = 0; iCent < nCentralityBins; iCent++) {
            grSyst->SetPoint(iCent, centralityPositions[iCent] + ptOffsets[iPt], v2Values[iCent]);
            grSyst->SetPointError(iCent, 0.05, 0.05, Systematics[iCent], Systematics[iCent]);
            
            grStat->SetPoint(iCent, centralityPositions[iCent] + ptOffsets[iPt], v2Values[iCent]);
            grStat->SetPointError(iCent, 0, v2Errors[iCent]);
        }

        Color_t colorWithAlpha = TColor::GetColorTransparent(colors[iPt], 0.35);
        grSyst->SetFillColor(colorWithAlpha);
        grSyst->SetFillStyle(3001);

        grStat->SetMarkerColor(colors[iPt]);
        grStat->SetMarkerStyle(markers[iPt]);

        mgAll->Add(grSyst, "2"); // Draw the shaded areas for systematic uncertainties
        mgAll->Add(grStat, "P"); // Draw the points with error bars for statistical uncertainties
        legend->AddEntry(grStat, ptBinLabels[iPt], "P");
    }

    // Draw the combined graph
    mgAll->Draw("A");
    mgAll->SetTitle("v2 vs Centrality;Centrality;v_{2}^{#pi^{0}}");
    mgAll->GetXaxis()->SetLimits(0.5, 3.5);
    mgAll->GetXaxis()->Set(nCentralityBins, 0.5, 3.5);
    mgAll->GetXaxis()->SetLabelOffset(0.02);
    

    for (int i = 1; i <= nCentralityBins; i++) {
        mgAll->GetXaxis()->SetBinLabel(i, centralityLabels[i-1]);
    }
    legend->Draw();
    DrawZeroLine(c_fun_of_centrality);
    c_fun_of_centrality->Modified();
    c_fun_of_centrality->Update();

    c_fun_of_centrality->SaveAs((BasePlotOutputPath + "/v2_FinalResults/v2_AsFunOfCentrality.png").c_str());
    
    

    /*
     OVERLAYING WITH PHENIX DATA FINAL RESULTS
     */
    //vectors for PHENIX data
    std::vector<double> v2_0_10, v2_0_10_Errors, v2_0_10_Errors_Negative, v2_10_20, v2_10_20_Errors, v2_10_20_Errors_Negative, v2_20_30, v2_20_30_Errors, v2_20_30_Errors_Negative, v2_30_40, v2_30_40_Errors, v2_30_40_Errors_Negative, v2_40_50, v2_40_50_Errors, v2_40_50_Errors_Negative, v2_50_60, v2_50_60_Errors, v2_50_60_Errors_Negative;
    
    // Read in PHENIX data and errors
    ReadPHENIXData(phenixFilePath, v2_0_10, v2_0_10_Errors, v2_0_10_Errors_Negative,
                   v2_10_20, v2_10_20_Errors, v2_10_20_Errors_Negative,
                   v2_20_30, v2_20_30_Errors, v2_20_30_Errors_Negative,
                   v2_30_40, v2_30_40_Errors, v2_30_40_Errors_Negative,
                   v2_40_50, v2_40_50_Errors, v2_40_50_Errors_Negative,
                   v2_50_60, v2_50_60_Errors, v2_50_60_Errors_Negative);
    
    // Average PHENIX data for each centrality, propagating errors accordingly
    PHENIX_data combinedData;
    CombineCentralityData(v2_0_10, v2_0_10_Errors, v2_10_20, v2_10_20_Errors,
                          combinedData.v2_0_20_PHENIX, combinedData.v2_0_20_Errors_PHENIX, 
                          v2_20_30, v2_20_30_Errors, v2_30_40, v2_30_40_Errors,
                          combinedData.v2_20_40_PHENIX, combinedData.v2_20_40_Errors_PHENIX,
                          v2_40_50, v2_40_50_Errors, v2_50_60, v2_50_60_Errors,
                          combinedData.v2_40_60_PHENIX, combinedData.v2_40_60_Errors_PHENIX);

    // Create graph for averaged PHENIX data
    TGraphErrors* graph_0_20_PHENIXdataAveraged = CreateGraph(ptCenters, combinedData.v2_0_20_PHENIX, combinedData.v2_0_20_Errors_PHENIX);
    TGraphErrors* graph_20_40_PHENIXdataAveraged = CreateGraph(ptCenters, combinedData.v2_20_40_PHENIX, combinedData.v2_20_40_Errors_PHENIX);
    TGraphErrors* graph_40_60_PHENIXdataAveraged = CreateGraph(ptCenters, combinedData.v2_40_60_PHENIX, combinedData.v2_40_60_Errors_PHENIX);
    
    setGraphProperties(graph_0_20_PHENIXdataAveraged, kBlue, kBlue, 1.0, 20);
    setGraphProperties(graph_20_40_PHENIXdataAveraged, kBlue, kBlue, 1.0, 20);
    setGraphProperties(graph_40_60_PHENIXdataAveraged, kBlue, kBlue, 1.0, 20);
    
    std::vector<double> sysErrors_0_20_PHENIX = CalculatePHENIXsystematicError(combinedData.v2_0_20_PHENIX, 0.1, 0.1);
    TGraphErrors* sys_graph_0_20_PHENIX = CreateSystematicGraph(ptCenters, combinedData.v2_0_20_PHENIX, combinedData.v2_0_20_Errors_PHENIX, sysErrors_0_20_PHENIX);
    sys_graph_0_20_PHENIX->SetFillColor(kBlue);
    sys_graph_0_20_PHENIX->SetFillStyle(3001);
    
    std::vector<double> sysErrors_20_40_PHENIX = CalculatePHENIXsystematicError(combinedData.v2_20_40_PHENIX, 0.05, 0.03);
    TGraphErrors* sys_graph_20_40_PHENIX = CreateSystematicGraph(ptCenters, combinedData.v2_20_40_PHENIX, combinedData.v2_20_40_Errors_PHENIX, sysErrors_20_40_PHENIX);
    sys_graph_20_40_PHENIX->SetFillColor(kBlue);
    sys_graph_20_40_PHENIX->SetFillStyle(3001);

    std::vector<double> sysErrors_40_60_PHENIX = CalculatePHENIXsystematicError(combinedData.v2_40_60_PHENIX, 0.1, 0.03);
    TGraphErrors* sys_graph_40_60_PHENIX = CreateSystematicGraph(ptCenters, combinedData.v2_40_60_PHENIX, combinedData.v2_40_60_Errors_PHENIX, sysErrors_40_60_PHENIX);
    sys_graph_40_60_PHENIX->SetFillColor(kBlue); // Gray color
    sys_graph_40_60_PHENIX->SetFillStyle(3001); // Semi-transparent fill
    
    std::cout << "\033[1;31mGraphing Averaged PHENIX data\033[0m" << std::endl;
    printGraphData("0-20%", graph_0_20_PHENIXdataAveraged, sys_graph_0_20_PHENIX);
    printGraphData("20-40%", graph_20_40_PHENIXdataAveraged, sys_graph_20_40_PHENIX);
    printGraphData("40-60%", graph_40_60_PHENIXdataAveraged, sys_graph_40_60_PHENIX);
    
    //offset graphs within each pT bin to avoid overlap in overlay
    for (int i = 0; i < ptCenters.size(); ++i) {
        sys_v2_0_20_graph_1->SetPoint(i, ptCenters[i] - .08, data1.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] - .08, data1.corrected_v2_0_20[i]);
        
        graph_0_20_PHENIXdataAveraged->SetPoint(i, ptCenters[i] + .08, combinedData.v2_0_20_PHENIX[i]);
        sys_graph_0_20_PHENIX->SetPoint(i, ptCenters[i] + .08, combinedData.v2_0_20_PHENIX[i]);
        
        sys_v2_20_40_graph_1->SetPoint(i, ptCenters[i] - .08, data1.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] - .08, data1.corrected_v2_20_40[i]);
        
        graph_20_40_PHENIXdataAveraged->SetPoint(i, ptCenters[i] + .08, combinedData.v2_20_40_PHENIX[i]);
        sys_graph_20_40_PHENIX->SetPoint(i, ptCenters[i] + .08, combinedData.v2_20_40_PHENIX[i]);
        
        sys_v2_40_60_graph_1->SetPoint(i, ptCenters[i] - .08, data1.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] - .08, data1.corrected_v2_40_60[i]);
        
        graph_40_60_PHENIXdataAveraged->SetPoint(i, ptCenters[i] + .08, combinedData.v2_40_60_PHENIX[i]);
        sys_graph_40_60_PHENIX->SetPoint(i, ptCenters[i] + .08, combinedData.v2_40_60_PHENIX[i]);
    }
    
    auto create_PHENIX_sPHENIX_graph = [&data1](TCanvas* canvas, TGraphErrors* graph1, TGraphErrors* graph2, TGraphErrors* graph3, TGraphErrors* graph4,  const std::string& centrality) {
        graph1->Draw("A2");
        graph2->Draw("P SAME");
        graph3->Draw("2 SAME");
        graph1->GetXaxis()->SetLimits(2.0, 5.0);
        graph4->Draw("P SAME");
        graph1->GetXaxis()->SetTitle("p_{T} [GeV]");
        graph1->GetYaxis()->SetTitle("v_{2}^{#pi^{0}}");
        graph1->SetMinimum(minYaxis);
        graph1->SetMaximum(maxYaxis);
        DrawZeroLine(canvas);
        Create_sPHENIX_legend(canvas, 0.14,.19,0.34,.39, centrality.c_str(), 0.045);
        TLegend *leg = new TLegend(0.8,.19,0.9,.4);
        leg->SetTextSize(0.029);
        leg->AddEntry(graph3, "PHENIX", "pef");
        leg->AddEntry(graph1, "sPHENIX", "pef");
        leg->Draw("same");
    };
    
    
    TCanvas *c_Overlay_ResultsWithPHENIX_0_20 = new TCanvas("c_Overlay_ResultsWithPHENIX_0_20", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    create_PHENIX_sPHENIX_graph(c_Overlay_ResultsWithPHENIX_0_20, sys_v2_0_20_graph_1, corrected_v2_0_20_graph_1, sys_graph_0_20_PHENIX, graph_0_20_PHENIXdataAveraged, "0-20% Centrality");
    c_Overlay_ResultsWithPHENIX_0_20->SaveAs((BasePlotOutputPath + "/v2_FinalResults/v2_Overlay_withPHENIX/Final_v2_withSyst_0_20_OverlayedWithPHENIX.png").c_str());
    
    //20-40% PHENIX overlay
    TCanvas *c_Overlay_ResultsWithPHENIX_20_40 = new TCanvas("c_Overlay_ResultsWithPHENIX_20_40", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    create_PHENIX_sPHENIX_graph(c_Overlay_ResultsWithPHENIX_20_40, sys_v2_20_40_graph_1, corrected_v2_20_40_graph_1, sys_graph_20_40_PHENIX, graph_20_40_PHENIXdataAveraged, "20-40% Centrality");
    c_Overlay_ResultsWithPHENIX_20_40->SaveAs((BasePlotOutputPath + "/v2_FinalResults/v2_Overlay_withPHENIX/Final_v2_withSyst_20_40_OverlayedWithPHENIX.png").c_str());
    
    //40-60% Centrality PHENIX overlay
    TCanvas *c_Overlay_ResultsWithPHENIX_40_60 = new TCanvas("c_Overlay_ResultsWithPHENIX_40_60", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    create_PHENIX_sPHENIX_graph(c_Overlay_ResultsWithPHENIX_40_60, sys_v2_40_60_graph_1, corrected_v2_40_60_graph_1, sys_graph_40_60_PHENIX, graph_40_60_PHENIXdataAveraged, "40-60% Centrality");
    c_Overlay_ResultsWithPHENIX_40_60->SaveAs((BasePlotOutputPath + "/v2_FinalResults/v2_Overlay_withPHENIX/Final_v2_withSyst_40_60_OverlayedWithPHENIX.png").c_str());
}
//Next two functions are For automatic y axis scaling of the Systematics Graphs
double FindMaxValueFromPlottedData(const std::vector<double>& values) {
    double maxVal = *std::max_element(values.begin(), values.end());
    return maxVal;
}
void AdjustFrameYAxis(TCanvas* canvas, TH1F* frame, double maxYValue) {
    if (frame) {
        frame->GetYaxis()->SetRangeUser(0, maxYValue);
        canvas->Modified();
        canvas->Update();
    }
}
/*
 Legend for EMCal Scale Systematic Contributors
 */
void DrawLegend_EMCal_Contributors(double x1, double y1, double x2, double y2, double textSize, const std::string& headerType, const std::string& centrality, const std::vector<TH1F*>& histograms, const std::vector<std::string>& labels) {
    TLegend *legend = new TLegend(x1, y1, x2, y2);
    legend->SetTextSize(textSize);
    std::string header = "#bf{" + headerType + " Uncertainties, " + centrality + "}";
    legend->SetHeader(header.c_str(), "L");
    // Add entries to the legend
    for (size_t i = 0; i < histograms.size(); ++i) {
        if (i < labels.size()) {
            legend->AddEntry(histograms[i], labels[i].c_str(), "f");
        }
    }
    legend->Draw();
}
void plotting_EMCal_Syst_Contributors(const EMCal_Systematic_Data& EMCal_Systematic_data1) {
    std::vector<double> ptCenters = {2.25, 2.75, 3.25, 3.75, 4.25, 4.75}; // Mid-points of pT ranges
    double barWidth = 0.05; // Width of each bar
    std::vector<std::string> labels = {"SYST1CEMC", "SYST2CEMC", "SYST3DCEMC", "SYST3UCEMC", "SYST4CEMC", "Quadrature Sum"};
    int colors[] = {kRed, kBlue, kGreen+1, kOrange+7, kViolet, kGray+1}; // Colors for the bars
    const double EPSILON = 1e-6;

    /*
     0-20% EMCal systematics contributors bar chart Relative
     */
    std::vector<TH1F*> histograms_0_20_Relative; // Vector to hold dummy histogram pointers for legend
    std::vector<double> collect_Values_0_20_Relative; // Vector to collect all values for determining the maximum value for Y-axis scaling later.
    TCanvas *c_Overlay_0_20_Systematics_Relative = new TCanvas("c_Overlay_0_20_Systematics_Relative", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    // Define the frame of the plot with x-axis and y-axis limits (upper y is placeholder, is automated)
    TH1F *frame_0_20_Relative = c_Overlay_0_20_Systematics_Relative->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_0_20_Relative->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_0_20_Relative->GetXaxis()->SetTitle("p_{T} [GeV]");
    // Loop over the pT centers to plot bars for each category of systematic uncertainty.
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        // Calculate the starting x position for the bars w/ adjusting for the bar width.
        double x = ptCenters[i] - (2.5 * barWidth);
        // Retrieve systematic uncertainty values for each category at the current pT center.
        std::vector<double> values_Relative = {
            EMCal_Systematic_data1.RelativeUncertainty_SYST1CEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST2CEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3DCEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3UCEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST4CEMC_0_20[i],
            EMCal_Systematic_data1.Relative_QuadSum_0_20[i]
        };
        /*
         Append all relative values to the global collector for max value computation later
         -- Done like this since in next graph, I skip a pT bin that overwelms plot to zoom in, and want this taken into acct in max y calculation
         */
        collect_Values_0_20_Relative.insert(collect_Values_0_20_Relative.end(), values_Relative.begin(), values_Relative.end());
        // Iterate over each systematic uncertainty category for the current pT value.
        for (size_t j = 0; j < values_Relative.size(); ++j) {
            // Calculate the x-axis position for each bar, w/ offset of 'j * barWidth' so they appear side by side without overlap.
            double xj = x + j * barWidth;
            /*
             Create histogram for current systematic category, where each has one bin, spanning from 'xj' to 'xj + barWidth', using 'Form' to name each histogram uniquely based on its pT index (i) and systematic category index (j).
             */
            TH1F *h_0_20_Relative = new TH1F(Form("h_0_20_Relative_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            // Set height to the value of the systematic uncertainty
            h_0_20_Relative->SetBinContent(1, values_Relative[j]);
            h_0_20_Relative->SetFillColor(colors[j]); // Set the color of the bar using a predefined array 'colors'
            h_0_20_Relative->Draw("SAME");
            histograms_0_20_Relative.push_back(h_0_20_Relative); // Save the histogram pointer for the legend
        }
    }
    double maxYValue_0_20_Relative = FindMaxValueFromPlottedData(collect_Values_0_20_Relative);
    AdjustFrameYAxis(c_Overlay_0_20_Systematics_Relative, frame_0_20_Relative, maxYValue_0_20_Relative * 1.05);
    DrawLegend_EMCal_Contributors(0.2, 0.65, 0.4, .9, 0.035, "Relative", "0-20%", histograms_0_20_Relative, labels);
    c_Overlay_0_20_Systematics_Relative->Modified();
    c_Overlay_0_20_Systematics_Relative->Update();
    c_Overlay_0_20_Systematics_Relative->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_0_20_RelativeUncertainty.png").c_str());
    
    //0-20% EMCal systematics contributors bar chart Relative Zoomed in
    std::vector<TH1F*> histograms_0_20_Relative_Zoomed_In;
    std::vector<double> collect_Values_0_20_Relative_Zoomed_In;
    TCanvas *c_Overlay_0_20_Systematics_Relative_Zoomed_In = new TCanvas("c_Overlay_0_20_Systematics_Relative_Zoomed_In", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    TH1F *frame_0_20_Relative_Zoomed_In = c_Overlay_0_20_Systematics_Relative_Zoomed_In->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_0_20_Relative_Zoomed_In->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_0_20_Relative_Zoomed_In->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        // Skip this pT center if it's within EPSILON of 3.75
        if (std::abs(ptCenters[i] - 3.75) < EPSILON) {
            continue;  // Skip the rest of the loop for this pT center
        }
        if (std::abs(ptCenters[i] - 4.25) < EPSILON) {
            continue;  // Skip the rest of the loop for this pT center
        }
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Relative_Zoomed_In = {
            EMCal_Systematic_data1.RelativeUncertainty_SYST1CEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST2CEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3DCEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3UCEMC_0_20[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST4CEMC_0_20[i],
            EMCal_Systematic_data1.Relative_QuadSum_0_20[i]
        };
        collect_Values_0_20_Relative_Zoomed_In.insert(collect_Values_0_20_Relative_Zoomed_In.end(), values_Relative_Zoomed_In.begin(), values_Relative_Zoomed_In.end());
        for (size_t j = 0; j < values_Relative_Zoomed_In.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_0_20_Relative_Zoomed_In = new TH1F(Form("h_0_20_Relative_Zoomed_In_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_0_20_Relative_Zoomed_In->SetBinContent(1, values_Relative_Zoomed_In[j]);
            h_0_20_Relative_Zoomed_In->SetFillColor(colors[j]);
            h_0_20_Relative_Zoomed_In->Draw("SAME");
            histograms_0_20_Relative_Zoomed_In.push_back(h_0_20_Relative_Zoomed_In);
        }
    }
    double maxYValue_0_20_Relative_Zoomed_In = FindMaxValueFromPlottedData(collect_Values_0_20_Relative_Zoomed_In);
    AdjustFrameYAxis(c_Overlay_0_20_Systematics_Relative_Zoomed_In, frame_0_20_Relative_Zoomed_In, maxYValue_0_20_Relative_Zoomed_In * 1.05);
    DrawLegend_EMCal_Contributors(0.57, 0.65, 0.67, .9, 0.035, "Relative", "0-20%", histograms_0_20_Relative_Zoomed_In, labels);
    c_Overlay_0_20_Systematics_Relative_Zoomed_In->Modified();
    c_Overlay_0_20_Systematics_Relative_Zoomed_In->Update();
    c_Overlay_0_20_Systematics_Relative_Zoomed_In->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_0_20_Relative_Zoomed_In_Uncertainty.png").c_str());
    
    //Relative Systematic EMCal Contributor 20-40%
    std::vector<TH1F*> histograms_20_40_Relative;
    std::vector<double> collect_Values_20_40_Relative;
    TCanvas *c_Overlay_20_40_Systematics_Relative = new TCanvas("c_Overlay_20_40_Systematics_Relative", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    TH1F *frame_20_40_Relative = c_Overlay_20_40_Systematics_Relative->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_20_40_Relative->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_20_40_Relative->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Relative = {
            EMCal_Systematic_data1.RelativeUncertainty_SYST1CEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST2CEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3DCEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3UCEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST4CEMC_20_40[i],
            EMCal_Systematic_data1.Relative_QuadSum_20_40[i]
        };
        collect_Values_20_40_Relative.insert(collect_Values_20_40_Relative.end(), values_Relative.begin(), values_Relative.end());
        for (size_t j = 0; j < values_Relative.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_20_40_Relative = new TH1F(Form("h_20_40_Relative_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_20_40_Relative->SetBinContent(1, values_Relative[j]);
            h_20_40_Relative->SetFillColor(colors[j]);
            h_20_40_Relative->Draw("SAME");
            histograms_20_40_Relative.push_back(h_20_40_Relative);
        }
    }
    double maxYValue_20_40_Relative = FindMaxValueFromPlottedData(collect_Values_20_40_Relative);
    AdjustFrameYAxis(c_Overlay_20_40_Systematics_Relative, frame_20_40_Relative, maxYValue_20_40_Relative * 1.05);
    DrawLegend_EMCal_Contributors(0.2, 0.65, 0.4, .9, 0.035, "Relative", "20-40%", histograms_20_40_Relative, labels);
    c_Overlay_20_40_Systematics_Relative->Modified();
    c_Overlay_20_40_Systematics_Relative->Update();
    c_Overlay_20_40_Systematics_Relative->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_20_40_RelativeUncertainty.png").c_str());
    
    //20-40% Relative Zoomed in
    std::vector<TH1F*> histograms_20_40_Relative_Zoomed_In;
    std::vector<double> collect_Values_20_40_Relative_Zoomed_In;
    TCanvas *c_Overlay_20_40_Systematics_Relative_Zoomed_In = new TCanvas("c_Overlay_20_40_Systematics_Relative_Zoomed_In", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    TH1F *frame_20_40_Relative_Zoomed_In = c_Overlay_20_40_Systematics_Relative_Zoomed_In->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_20_40_Relative_Zoomed_In->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_20_40_Relative_Zoomed_In->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        if (std::abs(ptCenters[i] - 4.25) < EPSILON) {
            continue;
        }
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Relative_Zoomed_In = {
            EMCal_Systematic_data1.RelativeUncertainty_SYST1CEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST2CEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3DCEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3UCEMC_20_40[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST4CEMC_20_40[i],
            EMCal_Systematic_data1.Relative_QuadSum_20_40[i]
        };
        collect_Values_20_40_Relative_Zoomed_In.insert(collect_Values_20_40_Relative_Zoomed_In.end(), values_Relative_Zoomed_In.begin(), values_Relative_Zoomed_In.end());
        for (size_t j = 0; j < values_Relative_Zoomed_In.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_20_40_Relative_Zoomed_In = new TH1F(Form("h_20_40_Relative_Zoomed_In_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_20_40_Relative_Zoomed_In->SetBinContent(1, values_Relative_Zoomed_In[j]);
            h_20_40_Relative_Zoomed_In->SetFillColor(colors[j]);
            h_20_40_Relative_Zoomed_In->Draw("SAME");
            histograms_20_40_Relative_Zoomed_In.push_back(h_20_40_Relative_Zoomed_In);
        }
    }
    double maxYValue_20_40_Relative_Zoomed_In = FindMaxValueFromPlottedData(collect_Values_20_40_Relative_Zoomed_In);
    AdjustFrameYAxis(c_Overlay_20_40_Systematics_Relative_Zoomed_In, frame_20_40_Relative_Zoomed_In, maxYValue_20_40_Relative_Zoomed_In * 1.05);
    DrawLegend_EMCal_Contributors(0.19, 0.68, 0.39, .92, 0.032, "Relative", "20-40%", histograms_20_40_Relative_Zoomed_In, labels);
    c_Overlay_20_40_Systematics_Relative_Zoomed_In->Modified();
    c_Overlay_20_40_Systematics_Relative_Zoomed_In->Update();
    c_Overlay_20_40_Systematics_Relative_Zoomed_In->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_20_40_Relative_Zoomed_In_Uncertainty.png").c_str());
    
    //40-60 Relative
    std::vector<TH1F*> histograms_40_60_Relative;
    std::vector<double> collect_Values_40_60_Relative;
    TCanvas *c_Overlay_40_60_Systematics_Relative = new TCanvas("c_Overlay_40_60_Systematics_Relative", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    TH1F *frame_40_60_Relative = c_Overlay_40_60_Systematics_Relative->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_40_60_Relative->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_40_60_Relative->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Relative = {
            EMCal_Systematic_data1.RelativeUncertainty_SYST1CEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST2CEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3DCEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3UCEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST4CEMC_40_60[i],
            EMCal_Systematic_data1.Relative_QuadSum_40_60[i]
        };
        collect_Values_40_60_Relative.insert(collect_Values_40_60_Relative.end(), values_Relative.begin(), values_Relative.end());
        for (size_t j = 0; j < values_Relative.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_40_60_Relative = new TH1F(Form("h_40_60_Relative_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_40_60_Relative->SetBinContent(1, values_Relative[j]);
            h_40_60_Relative->SetFillColor(colors[j]);
            h_40_60_Relative->Draw("SAME");
            histograms_40_60_Relative.push_back(h_40_60_Relative);
        }
    }
    double maxYValue_40_60_Relative = FindMaxValueFromPlottedData(collect_Values_40_60_Relative);
    AdjustFrameYAxis(c_Overlay_40_60_Systematics_Relative, frame_40_60_Relative, maxYValue_40_60_Relative * 1.05);
    DrawLegend_EMCal_Contributors(0.2, 0.65, 0.4, .9, 0.035, "Relative", "40-60%", histograms_40_60_Relative, labels);
    c_Overlay_40_60_Systematics_Relative->Modified();
    c_Overlay_40_60_Systematics_Relative->Update();
    c_Overlay_40_60_Systematics_Relative->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_40_60_RelativeUncertainty.png").c_str());
    
    //40-60% Centrality Zoomed in Relative Syst
    std::vector<TH1F*> histograms_40_60_Relative_Zoomed_In;
    std::vector<double> collect_Values_40_60_Relative_Zoomed_In;
    TCanvas *c_Overlay_40_60_Systematics_Relative_Zoomed_In = new TCanvas("c_Overlay_40_60_Systematics_Relative_Zoomed_In", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    TH1F *frame_40_60_Relative_Zoomed_In = c_Overlay_40_60_Systematics_Relative_Zoomed_In->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_40_60_Relative_Zoomed_In->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_40_60_Relative_Zoomed_In->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        // Skip this pT center if it's within EPSILON of 3.75
        if (std::abs(ptCenters[i] - 4.75) < EPSILON) {
            continue;
        }
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Relative_Zoomed_In = {
            EMCal_Systematic_data1.RelativeUncertainty_SYST1CEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST2CEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3DCEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST3UCEMC_40_60[i],
            EMCal_Systematic_data1.RelativeUncertainty_SYST4CEMC_40_60[i],
            EMCal_Systematic_data1.Relative_QuadSum_40_60[i]
        };
        collect_Values_40_60_Relative_Zoomed_In.insert(collect_Values_40_60_Relative_Zoomed_In.end(), values_Relative_Zoomed_In.begin(), values_Relative_Zoomed_In.end());
        for (size_t j = 0; j < values_Relative_Zoomed_In.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_40_60_Relative_Zoomed_In = new TH1F(Form("h_40_60_Relative_Zoomed_In_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_40_60_Relative_Zoomed_In->SetBinContent(1, values_Relative_Zoomed_In[j]);
            h_40_60_Relative_Zoomed_In->SetFillColor(colors[j]);
            h_40_60_Relative_Zoomed_In->Draw("SAME");
            histograms_40_60_Relative_Zoomed_In.push_back(h_40_60_Relative_Zoomed_In);
        }
    }
    double maxYValue_40_60_Relative_Zoomed_In = FindMaxValueFromPlottedData(collect_Values_40_60_Relative_Zoomed_In);
    AdjustFrameYAxis(c_Overlay_40_60_Systematics_Relative_Zoomed_In, frame_40_60_Relative_Zoomed_In, maxYValue_40_60_Relative_Zoomed_In * 1.05);
    DrawLegend_EMCal_Contributors(0.55, 0.68, 0.65, .93, 0.032, "Relative", "40-60%", histograms_40_60_Relative_Zoomed_In, labels);
    c_Overlay_40_60_Systematics_Relative_Zoomed_In->Modified();
    c_Overlay_40_60_Systematics_Relative_Zoomed_In->Update();
    c_Overlay_40_60_Systematics_Relative_Zoomed_In->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_40_60_Relative_Zoomed_In_Uncertainty.png").c_str());
    
    
    //0-20% Absolute Systematic EMCal contributor
    std::vector<TH1F*> histograms_0_20_Absolute;
    std::vector<double> collect_Values_0_20_Absolute;
    TCanvas *c_Overlay_0_20_Systematics_Absolute = new TCanvas("c_Overlay_0_20_Systematics_Absolute", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    TH1F *frame_0_20_Absolute = c_Overlay_0_20_Systematics_Absolute->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_0_20_Absolute->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_0_20_Absolute->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Absolute = {
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST1CEMC_0_20[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST2CEMC_0_20[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST3DCEMC_0_20[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST3UCEMC_0_20[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST4CEMC_0_20[i],
            EMCal_Systematic_data1.Absolute_QuadSum_0_20[i]
        };
        collect_Values_0_20_Absolute.insert(collect_Values_0_20_Absolute.end(), values_Absolute.begin(), values_Absolute.end());
        for (size_t j = 0; j < values_Absolute.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_0_20_Absolute = new TH1F(Form("h_0_20_Absolute_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_0_20_Absolute->SetBinContent(1, values_Absolute[j]);
            h_0_20_Absolute->SetFillColor(colors[j]);
            h_0_20_Absolute->Draw("SAME");
            histograms_0_20_Absolute.push_back(h_0_20_Absolute);
        }
    }
    double maxYValue_0_20_Absolute = FindMaxValueFromPlottedData(collect_Values_0_20_Absolute);
    AdjustFrameYAxis(c_Overlay_0_20_Systematics_Absolute, frame_0_20_Absolute, maxYValue_0_20_Absolute * 1.05);
    DrawLegend_EMCal_Contributors(0.19, 0.65, 0.38, .9, 0.035, "Absolute", "0-20%", histograms_0_20_Absolute, labels);
    c_Overlay_0_20_Systematics_Absolute->Modified();
    c_Overlay_0_20_Systematics_Absolute->Update();
    c_Overlay_0_20_Systematics_Absolute->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_0_20_AbsoluteUncertainty.png").c_str());
    
    
    //20-40%
    std::vector<TH1F*> histograms_20_40_Absolute;
    std::vector<double> collect_Values_20_40_Absolute;
    TCanvas *c_Overlay_20_40_Systematics_Absolute = new TCanvas("c_Overlay_20_40_Systematics_Absolute", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    TH1F *frame_20_40_Absolute = c_Overlay_20_40_Systematics_Absolute->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_20_40_Absolute->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_20_40_Absolute->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Absolute = {
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST1CEMC_20_40[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST2CEMC_20_40[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST3DCEMC_20_40[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST3UCEMC_20_40[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST4CEMC_20_40[i],
            EMCal_Systematic_data1.Absolute_QuadSum_20_40[i]
        };
        collect_Values_20_40_Absolute.insert(collect_Values_20_40_Absolute.end(), values_Absolute.begin(), values_Absolute.end());
        for (size_t j = 0; j < values_Absolute.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_20_40_Absolute = new TH1F(Form("h_20_40_Absolute_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_20_40_Absolute->SetBinContent(1, values_Absolute[j]);
            h_20_40_Absolute->SetFillColor(colors[j]);
            h_20_40_Absolute->Draw("SAME");
            histograms_20_40_Absolute.push_back(h_20_40_Absolute);
        }
    }
    double maxYValue_20_40_Absolute = FindMaxValueFromPlottedData(collect_Values_20_40_Absolute);
    AdjustFrameYAxis(c_Overlay_20_40_Systematics_Absolute, frame_20_40_Absolute, maxYValue_20_40_Absolute * 1.05);
    DrawLegend_EMCal_Contributors(0.2, 0.65, 0.4, .9, 0.035, "Absolute", "20-40%", histograms_20_40_Absolute, labels);
    c_Overlay_20_40_Systematics_Absolute->Modified();
    c_Overlay_20_40_Systematics_Absolute->Update();
    c_Overlay_20_40_Systematics_Absolute->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_20_40_AbsoluteUncertainty.png").c_str());
    
    //40-60%
    std::vector<TH1F*> histograms_40_60_Absolute;
    std::vector<double> collect_Values_40_60_Absolute;
    TCanvas *c_Overlay_40_60_Systematics_Absolute = new TCanvas("c_Overlay_40_60_Systematics_Absolute", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    TH1F *frame_40_60_Absolute = c_Overlay_40_60_Systematics_Absolute->DrawFrame(2.0, 0, 5.0, 0.62);
    frame_40_60_Absolute->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_40_60_Absolute->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_Absolute = {
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST1CEMC_40_60[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST2CEMC_40_60[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST3DCEMC_40_60[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST3UCEMC_40_60[i],
            EMCal_Systematic_data1.AbsoluteUncertainty_SYST4CEMC_40_60[i],
            EMCal_Systematic_data1.Absolute_QuadSum_40_60[i]
        };
        collect_Values_40_60_Absolute.insert(collect_Values_40_60_Absolute.end(), values_Absolute.begin(), values_Absolute.end());
        for (size_t j = 0; j < values_Absolute.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_40_60_Absolute = new TH1F(Form("h_40_60_Absolute_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_40_60_Absolute->SetBinContent(1, values_Absolute[j]);
            h_40_60_Absolute->SetFillColor(colors[j]);
            h_40_60_Absolute->Draw("SAME");
            histograms_40_60_Absolute.push_back(h_40_60_Absolute);
        }
    }
    double maxYValue_40_60_Absolute = FindMaxValueFromPlottedData(collect_Values_40_60_Absolute);
    AdjustFrameYAxis(c_Overlay_40_60_Systematics_Absolute, frame_40_60_Absolute, maxYValue_40_60_Absolute * 1.05);
    DrawLegend_EMCal_Contributors(0.2, 0.65, 0.4, .9, 0.035, "Absolute", "40-60%", histograms_40_60_Absolute, labels);
    c_Overlay_40_60_Systematics_Absolute->Modified();
    c_Overlay_40_60_Systematics_Absolute->Update();
    c_Overlay_40_60_Systematics_Absolute->SaveAs((baseDataPath_EmCal_Systematics + "EMCal_SystContributor_Overlay_40_60_AbsoluteUncertainty.png").c_str());
}
/*
 Legend generation for total systematic uncertainty contributors
 */
void Legend_Total_SystematicContributions(double x1, double y1, double x2, double y2, double textSize, const std::string& headerType, const std::vector<TH1F*>& histograms, const std::vector<std::string>& labels) {
    TLegend *legend = new TLegend(x1, y1, x2, y2);
    legend->SetTextSize(textSize);
    std::string header = "#bf{" + headerType + "}";
    legend->SetHeader(header.c_str(), "L");
    for (size_t i = 0; i < histograms.size(); ++i) {
        if (i < labels.size()) {
            legend->AddEntry(histograms[i], labels[i].c_str(), "f");
        }
    }
    legend->Draw();
}
//For plotting total systematic uncertainty contributions read in from StatUncertaintyTable_p015.csv
void plotting_Systematics(const Data& data1) {
    double barWidth = 0.05;
    int colors[] = {kRed, kBlue, kGreen+1, kGray+1};
    std::vector<std::string> labels_Total_SystematicContributors = {"EMCal Scale", "Signal Window", "Background Window", "Final Systematic Uncertainty"};
    const double EPSILON = 1e-6; //used to skip pT bins for a zoomed in plot in relative syst bar charts
    
    //0-20% Relative Uncertainty, include all data
    std::vector<TH1F*> histograms_0_20_RelativeUncertainty;
    std::vector<double> collect_Values_0_20_Relative; //used for y axis scaling
    TCanvas *c_Overlay_0_20_Systematics_RelativeUncertainty = new TCanvas("c_Overlay_0_20_Systematics_RelativeUncertainty", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    TH1F *frame_0_20_RelativeUncertainty = c_Overlay_0_20_Systematics_RelativeUncertainty->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_0_20_RelativeUncertainty->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_0_20_RelativeUncertainty->GetXaxis()->SetTitle("p_{T} [GeV]");

    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        
        std::vector<double> values_RelativeUncertainty_0_20 = {
            data1.quad_sum_EMCal_syst_0_20[i],
            data1.signal_window_syst_0_20[i],
            data1.background_window_syst_0_20[i],
            data1.unWeighted_total_syst_uncertainties_0_20[i]
        };
        collect_Values_0_20_Relative.insert(collect_Values_0_20_Relative.end(), values_RelativeUncertainty_0_20.begin(), values_RelativeUncertainty_0_20.end());

        for (size_t j = 0; j < values_RelativeUncertainty_0_20.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_0_20_RelativeUncertainty = new TH1F(Form("h_0_20_RelativeUncertainty_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_0_20_RelativeUncertainty->SetBinContent(1, values_RelativeUncertainty_0_20[j]);
            h_0_20_RelativeUncertainty->SetFillColor(colors[j]);
            h_0_20_RelativeUncertainty->Draw("SAME");
            histograms_0_20_RelativeUncertainty.push_back(h_0_20_RelativeUncertainty);
        }
        
    }
    double maxYValue_0_20_Relative = FindMaxValueFromPlottedData(collect_Values_0_20_Relative);
    AdjustFrameYAxis(c_Overlay_0_20_Systematics_RelativeUncertainty, frame_0_20_RelativeUncertainty, maxYValue_0_20_Relative * 1.05);
    Legend_Total_SystematicContributions(0.2, 0.72, 0.4, 0.92, 0.03, "Relative Systematics, 0-20%", histograms_0_20_RelativeUncertainty, labels_Total_SystematicContributors);
    c_Overlay_0_20_Systematics_RelativeUncertainty->SaveAs((SystematicsBasePlotOutput + "RelativeSystUncertainty_Overlay_0_20.png").c_str());
    
    //0-20% same plot as above but zoomed in on pT bins that were hard to see
    std::vector<TH1F*> histograms_0_20_RelativeUncertainty_ZoomedIn;
    std::vector<double> collect_Values_0_20_Relative_ZoomedIn;
    TCanvas *c_Overlay_0_20_Systematics_RelativeUncertainty_ZoomedIn = new TCanvas("c_Overlay_0_20_Systematics_RelativeUncertainty_ZoomedIn", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    TH1F *frame_0_20_RelativeUncertainty_ZoomedIn = c_Overlay_0_20_Systematics_RelativeUncertainty_ZoomedIn->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_0_20_RelativeUncertainty_ZoomedIn->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_0_20_RelativeUncertainty_ZoomedIn->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        //skip data that over powered previous graph
        if (std::abs(ptCenters[i] - 3.75) < EPSILON) {
            continue;
        }
        if (std::abs(ptCenters[i] - 4.25) < EPSILON) {
            continue;
        }
        double x = ptCenters[i] - (2.5 * barWidth);
        std::vector<double> values_RelativeUncertainty_0_20_ZoomedIn = {
            data1.quad_sum_EMCal_syst_0_20[i],
            data1.signal_window_syst_0_20[i],
            data1.background_window_syst_0_20[i],
            data1.unWeighted_total_syst_uncertainties_0_20[i]
        };
        collect_Values_0_20_Relative_ZoomedIn.insert(collect_Values_0_20_Relative_ZoomedIn.end(), values_RelativeUncertainty_0_20_ZoomedIn.begin(), values_RelativeUncertainty_0_20_ZoomedIn.end());
        for (size_t j = 0; j < values_RelativeUncertainty_0_20_ZoomedIn.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_0_20_RelativeUncertainty_ZoomedIn = new TH1F(Form("h_0_20_RelativeUncertainty_ZoomedIn_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_0_20_RelativeUncertainty_ZoomedIn->SetBinContent(1, values_RelativeUncertainty_0_20_ZoomedIn[j]);
            h_0_20_RelativeUncertainty_ZoomedIn->SetFillColor(colors[j]);
            h_0_20_RelativeUncertainty_ZoomedIn->Draw("SAME");
            histograms_0_20_RelativeUncertainty_ZoomedIn.push_back(h_0_20_RelativeUncertainty_ZoomedIn);
        }
        
    }
    double maxYValue_0_20_Relative_ZoomedIn = FindMaxValueFromPlottedData(collect_Values_0_20_Relative_ZoomedIn);
    AdjustFrameYAxis(c_Overlay_0_20_Systematics_RelativeUncertainty_ZoomedIn, frame_0_20_RelativeUncertainty_ZoomedIn, maxYValue_0_20_Relative_ZoomedIn * 1.05);
    Legend_Total_SystematicContributions(0.55, 0.72, 0.75, 0.92, 0.028, "Relative Systematics, 0-20%", histograms_0_20_RelativeUncertainty_ZoomedIn, labels_Total_SystematicContributors);
    c_Overlay_0_20_Systematics_RelativeUncertainty_ZoomedIn->SaveAs((SystematicsBasePlotOutput + "RelativeSystUncertainty_Overlay_0_20_Zoomed_In.png").c_str());
    
    //20-40% Centrality
    std::vector<TH1F*> histograms_20_40_RelativeUncertainty;
    std::vector<double> collect_Values_20_40_Relative;
    TCanvas *c_Overlay_20_40_Systematics_RelativeUncertainty = new TCanvas("c_Overlay_20_40_Systematics_RelativeUncertainty", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    TH1F *frame_20_40_RelativeUncertainty = c_Overlay_20_40_Systematics_RelativeUncertainty->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_20_40_RelativeUncertainty->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_20_40_RelativeUncertainty->GetXaxis()->SetTitle("p_{T} [GeV]");
    
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        
        std::vector<double> values_RelativeUncertainty_20_40 = {
            data1.quad_sum_EMCal_syst_20_40[i],
            data1.signal_window_syst_20_40[i],
            data1.background_window_syst_20_40[i],
            data1.unWeighted_total_syst_uncertainties_20_40[i]
        };
        collect_Values_20_40_Relative.insert(collect_Values_20_40_Relative.end(), values_RelativeUncertainty_20_40.begin(), values_RelativeUncertainty_20_40.end());
        
        for (size_t j = 0; j < values_RelativeUncertainty_20_40.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_20_40_RelativeUncertainty = new TH1F(Form("h_20_40_RelativeUncertainty_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_20_40_RelativeUncertainty->SetBinContent(1, values_RelativeUncertainty_20_40[j]);
            h_20_40_RelativeUncertainty->SetFillColor(colors[j]);
            h_20_40_RelativeUncertainty->Draw("SAME");
            histograms_20_40_RelativeUncertainty.push_back(h_20_40_RelativeUncertainty);
        }
        
    }
    double maxYValue_20_40_Relative = FindMaxValueFromPlottedData(collect_Values_20_40_Relative);
    AdjustFrameYAxis(c_Overlay_20_40_Systematics_RelativeUncertainty, frame_20_40_RelativeUncertainty, maxYValue_20_40_Relative * 1.05);
    Legend_Total_SystematicContributions(0.2, 0.72, 0.4, 0.92, 0.03, "Relative Systematics, 20-40%", histograms_20_40_RelativeUncertainty, labels_Total_SystematicContributors);
    c_Overlay_20_40_Systematics_RelativeUncertainty->Modified();
    c_Overlay_20_40_Systematics_RelativeUncertainty->Update();
    c_Overlay_20_40_Systematics_RelativeUncertainty->SaveAs((SystematicsBasePlotOutput + "RelativeSystUncertainty_Overlay_20_40.png").c_str());
    
    //20-40 Zoomed in
    std::vector<TH1F*> histograms_20_40_RelativeUncertainty_ZoomedIn;
    std::vector<double> collect_Values_20_40_Relative_ZoomedIn;
    TCanvas *c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn = new TCanvas("c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    TH1F *frame_20_40_RelativeUncertainty_ZoomedIn = c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_20_40_RelativeUncertainty_ZoomedIn->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_20_40_RelativeUncertainty_ZoomedIn->GetXaxis()->SetTitle("p_{T} [GeV]");
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        
        if (std::abs(ptCenters[i] - 4.25) < EPSILON) {
            continue;
        }
        double x = ptCenters[i] - (2.5 * barWidth);
        
        std::vector<double> values_RelativeUncertainty_20_40_ZoomedIn = {
            data1.quad_sum_EMCal_syst_20_40[i],
            data1.signal_window_syst_20_40[i],
            data1.background_window_syst_20_40[i],
            data1.unWeighted_total_syst_uncertainties_20_40[i]
        };
        collect_Values_20_40_Relative_ZoomedIn.insert(collect_Values_20_40_Relative_ZoomedIn.end(), values_RelativeUncertainty_20_40_ZoomedIn.begin(), values_RelativeUncertainty_20_40_ZoomedIn.end());
        
        for (size_t j = 0; j < values_RelativeUncertainty_20_40_ZoomedIn.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_20_40_RelativeUncertainty_ZoomedIn = new TH1F(Form("h_20_40_RelativeUncertainty_ZoomedIn_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_20_40_RelativeUncertainty_ZoomedIn->SetBinContent(1, values_RelativeUncertainty_20_40_ZoomedIn[j]);
            h_20_40_RelativeUncertainty_ZoomedIn->SetFillColor(colors[j]);
            h_20_40_RelativeUncertainty_ZoomedIn->Draw("SAME");
            histograms_20_40_RelativeUncertainty_ZoomedIn.push_back(h_20_40_RelativeUncertainty_ZoomedIn);
        }
        
    }
    double maxYValue_20_40_Relative_ZoomedIn = FindMaxValueFromPlottedData(collect_Values_20_40_Relative_ZoomedIn);
    AdjustFrameYAxis(c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn, frame_20_40_RelativeUncertainty_ZoomedIn, maxYValue_20_40_Relative_ZoomedIn * 1.05);
    Legend_Total_SystematicContributions(0.65, 0.72, 0.8, 0.9, 0.027, "Relative Systematics, 20-40%", histograms_20_40_RelativeUncertainty_ZoomedIn, labels_Total_SystematicContributors);
    c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn->Modified();
    c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn->Update();
    c_Overlay_20_40_Systematics_RelativeUncertainty_ZoomedIn->SaveAs((SystematicsBasePlotOutput + "RelativeSystUncertainty_Overlay_20_40_Zoomed_In.png").c_str());
    
    //40-60 Percent Centrality
    std::vector<TH1F*> histograms_40_60_RelativeUncertainty;
    std::vector<double> collect_Values_40_60_Relative;
    TCanvas *c_Overlay_40_60_Systematics_RelativeUncertainty = new TCanvas("c_Overlay_40_60_Systematics_RelativeUncertainty", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    TH1F *frame_40_60_RelativeUncertainty = c_Overlay_40_60_Systematics_RelativeUncertainty->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_40_60_RelativeUncertainty->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_40_60_RelativeUncertainty->GetXaxis()->SetTitle("p_{T} [GeV]");
    
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        
        std::vector<double> values_RelativeUncertainty_40_60 = {
            data1.quad_sum_EMCal_syst_40_60[i],
            data1.signal_window_syst_40_60[i],
            data1.background_window_syst_40_60[i],
            data1.unWeighted_total_syst_uncertainties_40_60[i]
        };
        collect_Values_40_60_Relative.insert(collect_Values_40_60_Relative.end(), values_RelativeUncertainty_40_60.begin(), values_RelativeUncertainty_40_60.end());
        
        for (size_t j = 0; j < values_RelativeUncertainty_40_60.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_40_60_RelativeUncertainty = new TH1F(Form("h_40_60_RelativeUncertainty_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_40_60_RelativeUncertainty->SetBinContent(1, values_RelativeUncertainty_40_60[j]);
            h_40_60_RelativeUncertainty->SetFillColor(colors[j]);
            h_40_60_RelativeUncertainty->Draw("SAME");
            histograms_40_60_RelativeUncertainty.push_back(h_40_60_RelativeUncertainty);
        }
        
    }
    double maxYValue_40_60_Relative = FindMaxValueFromPlottedData(collect_Values_40_60_Relative);
    AdjustFrameYAxis(c_Overlay_40_60_Systematics_RelativeUncertainty, frame_40_60_RelativeUncertainty, maxYValue_40_60_Relative * 1.05);
    Legend_Total_SystematicContributions(0.2, 0.72, 0.4, 0.92, 0.03, "Relative Systematics, 40-60%", histograms_40_60_RelativeUncertainty, labels_Total_SystematicContributors);
    c_Overlay_40_60_Systematics_RelativeUncertainty->Modified();
    c_Overlay_40_60_Systematics_RelativeUncertainty->Update();
    c_Overlay_40_60_Systematics_RelativeUncertainty->SaveAs((SystematicsBasePlotOutput + "RelativeSystUncertainty_Overlay_40_60.png").c_str());
    
    //40-60% Centrality Zoomed In
    std::vector<TH1F*> histograms_40_60_RelativeUncertainty_ZoomedIn;
    std::vector<double> collect_Values_40_60_Relative_ZoomedIn;
    
    TCanvas *c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn = new TCanvas("c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    TH1F *frame_40_60_RelativeUncertainty_ZoomedIn = c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_40_60_RelativeUncertainty_ZoomedIn->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_40_60_RelativeUncertainty_ZoomedIn->GetXaxis()->SetTitle("p_{T} [GeV]");
    
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        
        if (std::abs(ptCenters[i] - 4.75) < EPSILON) {
            continue;
        }

        double x = ptCenters[i] - (2.5 * barWidth);
        
        std::vector<double> values_RelativeUncertainty_40_60_ZoomedIn = {
            data1.quad_sum_EMCal_syst_40_60[i],
            data1.signal_window_syst_40_60[i],
            data1.background_window_syst_40_60[i],
            data1.unWeighted_total_syst_uncertainties_40_60[i]
        };
        collect_Values_40_60_Relative_ZoomedIn.insert(collect_Values_40_60_Relative_ZoomedIn.end(), values_RelativeUncertainty_40_60_ZoomedIn.begin(), values_RelativeUncertainty_40_60_ZoomedIn.end());
        
        for (size_t j = 0; j < values_RelativeUncertainty_40_60_ZoomedIn.size(); ++j) {
            double xj = x + j * barWidth;
            TH1F *h_40_60_RelativeUncertainty_ZoomedIn = new TH1F(Form("h_40_60_RelativeUncertainty_ZoomedIn_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_40_60_RelativeUncertainty_ZoomedIn->SetBinContent(1, values_RelativeUncertainty_40_60_ZoomedIn[j]);
            h_40_60_RelativeUncertainty_ZoomedIn->SetFillColor(colors[j]);
            h_40_60_RelativeUncertainty_ZoomedIn->Draw("SAME");
            histograms_40_60_RelativeUncertainty_ZoomedIn.push_back(h_40_60_RelativeUncertainty_ZoomedIn);
        }
        
    }
    double maxYValue_40_60_Relative_ZoomedIn = FindMaxValueFromPlottedData(collect_Values_40_60_Relative_ZoomedIn);
    AdjustFrameYAxis(c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn, frame_40_60_RelativeUncertainty_ZoomedIn, maxYValue_40_60_Relative_ZoomedIn * 1.05);
    Legend_Total_SystematicContributions(0.52, 0.73, 0.65, 0.92, 0.025, "Relative Systematics, 40-60%", histograms_40_60_RelativeUncertainty_ZoomedIn, labels_Total_SystematicContributors);
    c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn->Modified();
    c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn->Update();
    c_Overlay_40_60_Systematics_RelativeUncertainty_ZoomedIn->SaveAs((SystematicsBasePlotOutput + "RelativeSystUncertainty_Overlay_40_60_Zoomed_In.png").c_str());
    
    /*
     Absolute Uncertainties are the following 3 graphs below
     */
    //0-20% Centrality
    std::vector<TH1F*> histograms_0_20_AbsoluteUncertainty;
    std::vector<double> collect_Values_0_20_Absolute;
    
    TCanvas *c_Overlay_0_20_Systematics_AbsoluteUncertainty = new TCanvas("c_Overlay_0_20_Systematics_AbsoluteUncertainty", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    TH1F *frame_0_20_AbsoluteUncertainty = c_Overlay_0_20_Systematics_AbsoluteUncertainty->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_0_20_AbsoluteUncertainty->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_0_20_AbsoluteUncertainty->GetXaxis()->SetTitle("p_{T} [GeV]");
    
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        double v2_value = std::abs(data1.corrected_v2_0_20[i]);
        
        std::vector<double> values_AbsoluteUncertainty_0_20 = {
            data1.quad_sum_EMCal_syst_0_20[i] * v2_value,
            data1.signal_window_syst_0_20[i] * v2_value,
            data1.background_window_syst_0_20[i] * v2_value,
            data1.total_syst_uncertainties_0_20[i]
        };
        collect_Values_0_20_Absolute.insert(collect_Values_0_20_Absolute.end(), values_AbsoluteUncertainty_0_20.begin(), values_AbsoluteUncertainty_0_20.end());
        
        for (size_t j = 0; j < values_AbsoluteUncertainty_0_20.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_0_20_AbsoluteUncertainty = new TH1F(Form("h_0_20_AbsoluteUncertainty_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_0_20_AbsoluteUncertainty->SetBinContent(1, values_AbsoluteUncertainty_0_20[j]);
            h_0_20_AbsoluteUncertainty->SetFillColor(colors[j]);
            h_0_20_AbsoluteUncertainty->Draw("SAME");
            histograms_0_20_AbsoluteUncertainty.push_back(h_0_20_AbsoluteUncertainty);
        }
        
    }
    double maxYValue_0_20_Absolute = FindMaxValueFromPlottedData(collect_Values_0_20_Absolute);
    AdjustFrameYAxis(c_Overlay_0_20_Systematics_AbsoluteUncertainty, frame_0_20_AbsoluteUncertainty, maxYValue_0_20_Absolute * 1.05);
    Legend_Total_SystematicContributions(0.2, 0.72, 0.4, 0.92, 0.029, "Absolute Systematics, 0-20%", histograms_0_20_AbsoluteUncertainty, labels_Total_SystematicContributors);
    c_Overlay_0_20_Systematics_AbsoluteUncertainty->Modified();
    c_Overlay_0_20_Systematics_AbsoluteUncertainty->Update();
    c_Overlay_0_20_Systematics_AbsoluteUncertainty->SaveAs((SystematicsBasePlotOutput + "AbsoluteSystUncertainty_Overlay_0_20.png").c_str());
    
    //20-40% Centrality
    std::vector<TH1F*> histograms_20_40_AbsoluteUncertainty;
    std::vector<double> collect_Values_20_40_Absolute;
    TCanvas *c_Overlay_20_40_Systematics_AbsoluteUncertainty = new TCanvas("c_Overlay_20_40_Systematics_AbsoluteUncertainty", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    TH1F *frame_20_40_AbsoluteUncertainty = c_Overlay_20_40_Systematics_AbsoluteUncertainty->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_20_40_AbsoluteUncertainty->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_20_40_AbsoluteUncertainty->GetXaxis()->SetTitle("p_{T} [GeV]");
    
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        double v2_value = std::abs(data1.corrected_v2_20_40[i]);
        
        std::vector<double> values_AbsoluteUncertainty_20_40 = {
            data1.quad_sum_EMCal_syst_20_40[i] * v2_value,
            data1.signal_window_syst_20_40[i] * v2_value,
            data1.background_window_syst_20_40[i] * v2_value,
            data1.total_syst_uncertainties_20_40[i]
        };
        collect_Values_20_40_Absolute.insert(collect_Values_20_40_Absolute.end(), values_AbsoluteUncertainty_20_40.begin(), values_AbsoluteUncertainty_20_40.end());
        
        for (size_t j = 0; j < values_AbsoluteUncertainty_20_40.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_20_40_AbsoluteUncertainty = new TH1F(Form("h_20_40_AbsoluteUncertainty_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_20_40_AbsoluteUncertainty->SetBinContent(1, values_AbsoluteUncertainty_20_40[j]);
            h_20_40_AbsoluteUncertainty->SetFillColor(colors[j]);
            h_20_40_AbsoluteUncertainty->Draw("SAME");
            histograms_20_40_AbsoluteUncertainty.push_back(h_20_40_AbsoluteUncertainty);
        }
        
    }
    double maxYValue_20_40_Absolute = FindMaxValueFromPlottedData(collect_Values_20_40_Absolute);
    AdjustFrameYAxis(c_Overlay_20_40_Systematics_AbsoluteUncertainty, frame_20_40_AbsoluteUncertainty, maxYValue_20_40_Absolute * 1.05);
    Legend_Total_SystematicContributions(0.2, 0.72, 0.4, 0.92, 0.03, "Absolute Systematics, 20-40%", histograms_20_40_AbsoluteUncertainty, labels_Total_SystematicContributors);
    c_Overlay_20_40_Systematics_AbsoluteUncertainty->Modified();
    c_Overlay_20_40_Systematics_AbsoluteUncertainty->Update();
    c_Overlay_20_40_Systematics_AbsoluteUncertainty->SaveAs((SystematicsBasePlotOutput + "AbsoluteSystUncertainty_Overlay_20_40.png").c_str());
    
    //40-60% Centrality
    std::vector<TH1F*> histograms_40_60_AbsoluteUncertainty;
    std::vector<double> collect_Values_40_60_Absolute;
    TCanvas *c_Overlay_40_60_Systematics_AbsoluteUncertainty = new TCanvas("c_Overlay_40_60_Systematics_AbsoluteUncertainty", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    TH1F *frame_40_60_AbsoluteUncertainty = c_Overlay_40_60_Systematics_AbsoluteUncertainty->DrawFrame(2.0, 0, 5.0, 0.7);
    frame_40_60_AbsoluteUncertainty->GetYaxis()->SetTitle("Systematic Uncertainty");
    frame_40_60_AbsoluteUncertainty->GetXaxis()->SetTitle("p_{T} [GeV]");
    
    for (size_t i = 0; i < ptCenters.size(); ++i) {
        double x = ptCenters[i] - (2.5 * barWidth);
        double v2_value = std::abs(data1.corrected_v2_40_60[i]);
        
        std::vector<double> values_AbsoluteUncertainty_40_60 = {
            data1.quad_sum_EMCal_syst_40_60[i] * v2_value,
            data1.signal_window_syst_40_60[i] * v2_value, //to get absolute systematic uncertainty
            data1.background_window_syst_40_60[i] * v2_value, //to get absolute systematic uncertainty
            data1.total_syst_uncertainties_40_60[i] //already absolute syst
        };
        collect_Values_40_60_Absolute.insert(collect_Values_40_60_Absolute.end(), values_AbsoluteUncertainty_40_60.begin(), values_AbsoluteUncertainty_40_60.end());
        
        for (size_t j = 0; j < values_AbsoluteUncertainty_40_60.size(); ++j) {
            double xj = x + j * barWidth; // Adjust x position for each bar
            TH1F *h_40_60_AbsoluteUncertainty = new TH1F(Form("h_40_60_AbsoluteUncertainty_%zu_%zu", i, j), "", 1, xj, xj + barWidth);
            h_40_60_AbsoluteUncertainty->SetBinContent(1, values_AbsoluteUncertainty_40_60[j]);
            h_40_60_AbsoluteUncertainty->SetFillColor(colors[j]);
            h_40_60_AbsoluteUncertainty->Draw("SAME");
            histograms_40_60_AbsoluteUncertainty.push_back(h_40_60_AbsoluteUncertainty);
        }
        
    }
    double maxYValue_40_60_Absolute = FindMaxValueFromPlottedData(collect_Values_40_60_Absolute);
    AdjustFrameYAxis(c_Overlay_40_60_Systematics_AbsoluteUncertainty, frame_40_60_AbsoluteUncertainty, maxYValue_40_60_Absolute * 1.05);
    Legend_Total_SystematicContributions(0.2, 0.72, 0.4, 0.92, 0.03, "Absolute Systematics, 40-60%", histograms_40_60_AbsoluteUncertainty, labels_Total_SystematicContributors);
    c_Overlay_40_60_Systematics_AbsoluteUncertainty->Modified();
    c_Overlay_40_60_Systematics_AbsoluteUncertainty->Update();
    c_Overlay_40_60_Systematics_AbsoluteUncertainty->SaveAs((SystematicsBasePlotOutput + "AbsoluteSystUncertainty_Overlay_40_60.png").c_str());
}
/*
 next chunk of code UNTIL THE MAIN FUNCTION AT BOTTOM is for v2 overlays of systematic contributors as well as v2 cross checks like asymm, sample size, etc.
 */
void createAndDraw_2graphEntries(TCanvas* canvas, TGraph* graph1, TGraph* graph2, const char* entry1, const char* entry2, double x1, double y1, double x2, double y2, const std::string& legendTitle) {
    graph1->Draw("AP");
    graph2->Draw("P SAME");
    graph1->GetXaxis()->SetLimits(2.0, 5.0);
    graph1->GetXaxis()->SetTitle("p_{T} [GeV]");
    graph1->GetYaxis()->SetTitle("v_{2}^{#pi^{0}}");
    graph1->SetMinimum(minYaxis);
    graph1->SetMaximum(maxYaxis);
    TLegend *legend = new TLegend(x1, y1, x2, y2);
    legend->SetBorderSize(0);
    legend->SetTextSize(0.04);
    legend->AddEntry(graph2, entry1, "pe");
    legend->AddEntry(graph1, entry2, "pe");
    legend->Draw();
    DrawZeroLine(canvas);
    Create_sPHENIX_legend(canvas, 0.14, .72, 0.34, .92, legendTitle.c_str(), 0.045);
}
void logHeader(const std::string& message) {
    std::cout << "\033[1;31m" << message << "\033[0m" << std::endl;
}
void log(const std::string& message) {
    std::cout << message << std::endl;
}
// Generalized function to log data for any set of graphs
template<typename GraphContainer>
void logGraphData(const GraphContainer& graphs,
                  const std::vector<std::string>& descriptions,
                  const std::vector<std::string>& centralityLabels,
                  const std::vector<double>& ptCenters) {
    if (graphs.empty() || graphs[0].empty()) return;
    int numCentralities = graphs.size();
    int numDataSets = graphs[0].size();
    for (int centrality = 0; centrality < numCentralities; ++centrality) {
        // Loop through each dataset within a centrality
        for (int dataSet = 0; dataSet < numDataSets; ++dataSet) {
            // Ensure description and label arrays are large enough
            if (centrality >= centralityLabels.size() || dataSet >= descriptions.size()) continue;
            // Access the graph
            auto* graph = graphs[centrality][dataSet];
            if (!graph) continue;
            // Log the header information
            logHeader("Plotting " + descriptions[dataSet] + " for " + centralityLabels[centrality] + " centrality:");
            // Retrieve and log data points from the graph
            auto yValues = graph->GetY();
            auto errors = graph->GetEY();
            for (size_t i = 0; i < ptCenters.size(); ++i) {
                std::string logMessage = "pT: " + std::to_string(ptCenters[i]) + ", Value: " +
                                         std::to_string(yValues[i]) + ", Error: " + std::to_string(errors[i]);
                log(logMessage);
            }
        }
    }
}
/*
 Plot overlay of EMCal scale variations v2 values
 */
void plot_EMCal_Scale_v2_overlays(const Data& data1, Data& data2, Data& data3, Data& data4, Data& data5, Data& data6) {
    logHeader("Starting EMCal Scale Variations v2 Overlay");
    std::array<GraphProperties, 6> properties = {
        {{kBlack, 20, 1.0}, {kRed, 20, 1.0}, {kBlue, 20, 1.0}, {kGreen+2, 20, 1.0}, {kOrange+7, 20, 1.0}, {kViolet-2, 20, 1.0}}
    };
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_0_20, data2.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_20_40, data2.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_40_60, data2.corrected_v2_40_60_Errors);

    TGraphErrors* corrected_v2_0_20_graph_3 = CreateGraph(ptCenters, data3.corrected_v2_0_20, data3.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_3 = CreateGraph(ptCenters, data3.corrected_v2_20_40, data3.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_3 = CreateGraph(ptCenters, data3.corrected_v2_40_60, data3.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v2_0_20_graph_4 = CreateGraph(ptCenters, data4.corrected_v2_0_20, data4.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_4 = CreateGraph(ptCenters, data4.corrected_v2_20_40, data4.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_4 = CreateGraph(ptCenters, data4.corrected_v2_40_60, data4.corrected_v2_40_60_Errors);

    TGraphErrors* corrected_v2_0_20_graph_5 = CreateGraph(ptCenters, data5.corrected_v2_0_20, data5.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_5 = CreateGraph(ptCenters, data5.corrected_v2_20_40, data5.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_5 = CreateGraph(ptCenters, data5.corrected_v2_40_60, data5.corrected_v2_40_60_Errors);

    TGraphErrors* corrected_v2_0_20_graph_6 = CreateGraph(ptCenters, data6.corrected_v2_0_20, data6.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_6 = CreateGraph(ptCenters, data6.corrected_v2_20_40, data6.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_6 = CreateGraph(ptCenters, data6.corrected_v2_40_60, data6.corrected_v2_40_60_Errors);
    
    // Array of pointers to arrays of graph pointers (for each group of graphs)
    std::array<std::array<TGraph*, 6>, 3> allGraphs = {{
        {corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, corrected_v2_0_20_graph_3, corrected_v2_0_20_graph_4, corrected_v2_0_20_graph_5, corrected_v2_0_20_graph_6},
        {corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, corrected_v2_20_40_graph_3, corrected_v2_20_40_graph_4, corrected_v2_20_40_graph_5, corrected_v2_20_40_graph_6},
        {corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, corrected_v2_40_60_graph_3, corrected_v2_40_60_graph_4, corrected_v2_40_60_graph_5, corrected_v2_40_60_graph_6}
    }};

    // Use nested loops to set the properties for each graph in each group
    for (auto& graphGroup : allGraphs) {
        for (int i = 0; i < graphGroup.size(); ++i) {
            // Access the individual graph from the group.
            TGraph* graph = graphGroup[i];
            // Retrieve the properties for the current graph -- indexed to match each graph's position within its group.
            const auto& prop = properties[i];
            setGraphProperties(graph, prop.markerColor, prop.markerColor, prop.markerSize, prop.markerStyle);
        }
    }
    // Define array for easier access and logging
    std::vector<std::string> descriptions = {"Default", "SYST1CEMC", "SYST2CEMC", "SYST3DCEMC", "SYST3UCEMC", "SYST4CEMC"};
    logGraphData(allGraphs, descriptions, centralityLabels, ptCenters);
    
    for (int i = 0; i < ptCenters.size(); ++i) { //offset points to avoid overlap within each pT bin, drawing graph 4 at center
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] - 3.0 * offset, data1.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - 2.0 * offset, data2.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_3->SetPoint(i, ptCenters[i] - 1.0 * offset, data3.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_5->SetPoint(i, ptCenters[i] + 1.0 * offset, data5.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_6->SetPoint(i, ptCenters[i] + 2.0 * offset, data6.corrected_v2_0_20[i]);
        
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] - 3.0 * offset, data1.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - 2.0 * offset, data2.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_3->SetPoint(i, ptCenters[i] - 1.0 * offset, data3.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_5->SetPoint(i, ptCenters[i] + 1.0 * offset, data5.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_6->SetPoint(i, ptCenters[i] + 2.0 * offset, data6.corrected_v2_20_40[i]);

        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] - 3.0 * offset, data1.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - 2.0 * offset, data2.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_3->SetPoint(i, ptCenters[i] - 1.0 * offset, data3.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_5->SetPoint(i, ptCenters[i] + 1.0 * offset, data5.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_6->SetPoint(i, ptCenters[i] + 2.0 * offset, data6.corrected_v2_40_60[i]);
    }
    /*
     Plot Overlay Of EMCal Scale Variations for each centrality
     */
    auto create_EMCal_ScaleVariations = [&data1, &data2, &data3, &data4, &data5, &data6](TCanvas* canvas, TGraphErrors* graph1, TGraphErrors* graph2, TGraphErrors* graph3, TGraphErrors* graph4, TGraphErrors* graph5, TGraphErrors* graph6, const std::string& legendTitle) {
        graph4->Draw("AP");
        graph4->GetXaxis()->SetTitle("p_{T} [GeV]");
        graph4->GetYaxis()->SetTitle("v_{2}^{#pi^{0}}");
        graph1 -> Draw("P SAME");
        graph2 -> Draw("P SAME");
        graph3 -> Draw("P SAME");
        graph5 -> Draw("P SAME");
        graph6 -> Draw("P SAME");
        graph4->SetMinimum(minYaxis);
        graph4->SetMaximum(maxYaxis);
        TLegend *legend = new TLegend(0.17, 0.18, 0.56, 0.33);
        legend->SetNColumns(2);
        legend->SetBorderSize(0);
        legend->SetTextSize(0.028);
        legend->AddEntry(graph1, "Default", "pe");
        legend->AddEntry(graph2, "SYST1CEMC", "pe");
        legend->AddEntry(graph3, "SYST2CEMC", "pe");
        legend->AddEntry(graph4, "SYST3DCEMC", "pe");
        legend->AddEntry(graph5, "SYST3UCEMC", "pe");
        legend->AddEntry(graph6, "SYST4CEMC", "pe");
        legend->Draw();
        Create_sPHENIX_legend(canvas, 0.14,.72,0.34,.92, legendTitle.c_str(), 0.045);
        DrawZeroLine(canvas);
    };
    TCanvas *c_Overlay_0_20_v2_corrected_EMCal_Scale = new TCanvas("c_Overlay_0_20_v2_corrected_EMCal_Scale", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    logHeader("Drawing graphs for 0-20% centrality.");
    create_EMCal_ScaleVariations(c_Overlay_0_20_v2_corrected_EMCal_Scale, corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, corrected_v2_0_20_graph_3, corrected_v2_0_20_graph_4, corrected_v2_0_20_graph_5, corrected_v2_0_20_graph_6, "0-20% Centrality");
    c_Overlay_0_20_v2_corrected_EMCal_Scale->Modified();
    c_Overlay_0_20_v2_corrected_EMCal_Scale->Update();
    c_Overlay_0_20_v2_corrected_EMCal_Scale->SaveAs((baseDataPath_EmCal_Systematics + "EMCalScaleOverlay_v2Corrected_0_20.png").c_str());
    log("Saved the plot for 0-20% centrality.");
    
    TCanvas *c_Overlay_20_40_v2_corrected_EMCal_Scale = new TCanvas("c_Overlay_20_40_v2_corrected_EMCal_Scale", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    logHeader("Drawing graphs for 20-40% centrality.");
    create_EMCal_ScaleVariations(c_Overlay_20_40_v2_corrected_EMCal_Scale, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, corrected_v2_20_40_graph_3, corrected_v2_20_40_graph_4, corrected_v2_20_40_graph_5, corrected_v2_20_40_graph_6, "20-40% Centrality");
    c_Overlay_20_40_v2_corrected_EMCal_Scale->Modified();
    c_Overlay_20_40_v2_corrected_EMCal_Scale->Update();
    c_Overlay_20_40_v2_corrected_EMCal_Scale->SaveAs((baseDataPath_EmCal_Systematics + "EMCalScaleOverlay_v2Corrected_20_40.png").c_str());
    log("Saved the plot for 20-40% centrality.");
    
    TCanvas *c_Overlay_40_60_v2_corrected_EMCal_Scale = new TCanvas("c_Overlay_40_60_v2_corrected_EMCal_Scale", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    logHeader("Drawing graphs for 40-60% centrality.");
    create_EMCal_ScaleVariations(c_Overlay_40_60_v2_corrected_EMCal_Scale, corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, corrected_v2_40_60_graph_3, corrected_v2_40_60_graph_4, corrected_v2_40_60_graph_5, corrected_v2_40_60_graph_6, "40-60% Centrality");
    c_Overlay_40_60_v2_corrected_EMCal_Scale->Modified();
    c_Overlay_40_60_v2_corrected_EMCal_Scale->Update();
    c_Overlay_40_60_v2_corrected_EMCal_Scale->SaveAs((baseDataPath_EmCal_Systematics + "EMCalScaleOverlay_v2Corrected_40_60.png").c_str());
    log("Saved the plot for 40-60% centrality.");
}
void plot_SignalWindow_Variation(const Data& data1, Data& data2) {
    std::array<GraphProperties, 2> properties = {{
        {kBlack, 20, 1.0},  // Properties for data1
        {kBlue, 20, 1.0}    // Properties for data2
    }};
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_0_20, data2.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_20_40, data2.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_40_60, data2.corrected_v2_40_60_Errors);
    
    std::array<std::array<TGraphErrors*, 2>, 3> allGraphs = {{
        {corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2},
        {corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2},
        {corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2}
    }};
    for (auto& graphGroup : allGraphs) {
        for (int i = 0; i < graphGroup.size(); ++i) {
            TGraphErrors* graph = graphGroup[i];
            const GraphProperties& prop = properties[i];
            setGraphProperties(graph, prop.markerColor, prop.markerColor, prop.markerSize, prop.markerStyle);
        }
    }
    std::vector<std::string> descriptions = {"Signal Window = mean pm 2sigma (Default)", "Signal Window = mean pm 1.5sigma"};
    logGraphData(allGraphs, descriptions, centralityLabels, ptCenters);

    for (int i = 0; i < ptCenters.size(); ++i) {
        corrected_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_0_20[i]);
        
        corrected_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_20_40[i]);
        
        corrected_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_40_60[i]);
    }
    
    /*
     Plot Signal Window Variations for each centrality
     */
    TCanvas *c_Overlay_0_20_signalWindowVariation = new TCanvas("c_Overlay_0_20_signalWindowVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    logHeader("Drawing graphs for 0-20% centrality.");
    createAndDraw_2graphEntries(c_Overlay_0_20_signalWindowVariation, corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, "Signal Window = #mu #pm 1.50#sigma", "Signal Window = #mu #pm 2.00#sigma (Default)", 0.2, 0.18, 0.4, 0.33, "0-20% Centrality");
    c_Overlay_0_20_signalWindowVariation->Modified();
    c_Overlay_0_20_signalWindowVariation->Update();
    c_Overlay_0_20_signalWindowVariation->SaveAs((baseDataPath_SignalWindowVariations + "Overlay_0_20_v2_SignalWindowVariations.png").c_str());
    log("Saved the plot for 0-20% centrality.");

    TCanvas *c_Overlay_20_40_signalWindowVariation = new TCanvas("c_Overlay_20_40_signalWindowVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    logHeader("Drawing graphs for 20-40% centrality.");
    createAndDraw_2graphEntries(c_Overlay_20_40_signalWindowVariation, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, "Signal Window = #mu #pm 1.50#sigma", "Signal Window = #mu #pm 2.00#sigma (Default)", 0.2, 0.18, 0.4, 0.33, "20-40% Centrality");
    c_Overlay_20_40_signalWindowVariation->Modified();
    c_Overlay_20_40_signalWindowVariation->Update();
    c_Overlay_20_40_signalWindowVariation->SaveAs((baseDataPath_SignalWindowVariations + "Overlay_20_40_v2_SignalWindowVariations.png").c_str());
    log("Saved the plot for 20-40% centrality.");
    
    TCanvas *c_Overlay_40_60_signalWindowVariation = new TCanvas("c_Overlay_40_60_signalWindowVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    logHeader("Drawing graphs for 40-60% centrality.");
    createAndDraw_2graphEntries(c_Overlay_40_60_signalWindowVariation, corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, "Signal Window = #mu #pm 1.50#sigma", "Signal Window = #mu #pm 2.00#sigma (Default)", 0.2, 0.18, 0.4, 0.33, "40-60% Centrality");
    c_Overlay_40_60_signalWindowVariation->Modified();
    c_Overlay_40_60_signalWindowVariation->Update();
    c_Overlay_40_60_signalWindowVariation->SaveAs((baseDataPath_SignalWindowVariations + "Overlay_40_60_v2_SignalWindowVariations.png").c_str());
    log("Saved the plot for 40-60% centrality.");
}
void plot_SampleSize_Variations(const Data& data1, Data& data2) {
    std::array<GraphProperties, 2> properties = {{
        {kBlack, 20, 1.0},
        {kBlue, 20, 1.0}
    }};
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_0_20, data2.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_20_40, data2.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_40_60, data2.corrected_v2_40_60_Errors);

    std::array<std::array<TGraphErrors*, 2>, 3> allGraphs = {{
        {corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2},
        {corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2},
        {corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2}
    }};

    for (auto& graphGroup : allGraphs) {
        for (int i = 0; i < graphGroup.size(); ++i) {
            TGraphErrors* graph = graphGroup[i];
            const GraphProperties& prop = properties[i];
            setGraphProperties(graph, prop.markerColor, prop.markerColor, prop.markerSize, prop.markerStyle);
        }
    }
    std::vector<std::string> descriptions = {"30 Samples (Default)", "25 Samples"};
    logGraphData(allGraphs, descriptions, centralityLabels, ptCenters);
    
    for (int i = 0; i < ptCenters.size(); ++i) {
        corrected_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_0_20[i]);
        
        corrected_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_20_40[i]);
        
        corrected_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_40_60[i]);
    }
    
    /*
     Plot Sample Size Variations for each centrality
     */
    TCanvas *c_Overlay_0_20_sampleSizeVariation = new TCanvas("c_Overlay_0_20_sampleSizeVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_sampleSizeVariation, corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, "25 Samples", "30 Samples (Default)", 0.2, 0.18, 0.4, 0.33, "0-20% Centrality");
    c_Overlay_0_20_sampleSizeVariation->Modified();
    c_Overlay_0_20_sampleSizeVariation->Update();
    c_Overlay_0_20_sampleSizeVariation->SaveAs((baseDataPath_SampleSizeVariations + "Overlay_0_20_v2_sampleSizeVariations.png").c_str());

    TCanvas *c_Overlay_20_40_sampleSizeVariation = new TCanvas("c_Overlay_20_40_sampleSizeVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_20_40_sampleSizeVariation, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, "25 Samples", "30 Samples (Default)", 0.2, 0.18, 0.4, 0.33, "20-40% Centrality");
    c_Overlay_20_40_sampleSizeVariation->Modified();
    c_Overlay_20_40_sampleSizeVariation->Update();
    c_Overlay_20_40_sampleSizeVariation->SaveAs((baseDataPath_SampleSizeVariations + "Overlay_20_40_v2_sampleSizeVariations.png").c_str());

    TCanvas *c_Overlay_40_60_sampleSizeVariation = new TCanvas("c_Overlay_40_60_sampleSizeVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_40_60_sampleSizeVariation, corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, "25 Samples", "30 Samples (Default)", 0.2, 0.18, 0.4, 0.33, "40-60% Centrality");
    c_Overlay_40_60_sampleSizeVariation->Modified();
    c_Overlay_40_60_sampleSizeVariation->Update();
    c_Overlay_40_60_sampleSizeVariation->SaveAs((baseDataPath_SampleSizeVariations + "Overlay_40_60_v2_sampleSizeVariations.png").c_str());
}

void plot_AsymmetryCut_Variations(const Data& data1, Data& data2, Data& data3){
    std::array<GraphProperties, 3> properties = {
        {{kBlack, 20, 1.0}, {kBlue, 20, 1.0}, {kOrange+2, 20, 1.0}}
    };
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_0_20, data2.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_20_40, data2.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_40_60, data2.corrected_v2_40_60_Errors);

    TGraphErrors* corrected_v2_0_20_graph_3 = CreateGraph(ptCenters, data3.corrected_v2_0_20, data3.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_3 = CreateGraph(ptCenters, data3.corrected_v2_20_40, data3.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_3 = CreateGraph(ptCenters, data3.corrected_v2_40_60, data3.corrected_v2_40_60_Errors);

    // Array of pointers to arrays of graph pointers (for each group of graphs)
    std::array<std::array<TGraph*, 3>, 3> allGraphs = {{
        {corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, corrected_v2_0_20_graph_3},
        {corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, corrected_v2_20_40_graph_3},
        {corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, corrected_v2_40_60_graph_3}
    }};

    for (auto& graphGroup : allGraphs) {
        for (int i = 0; i < graphGroup.size(); ++i) {
            TGraph* graph = graphGroup[i];
            const auto& prop = properties[i];
            setGraphProperties(graph, prop.markerColor, prop.markerColor, prop.markerSize, prop.markerStyle);
        }
    }
    std::vector<std::string> descriptions = {"Asym < 0.5 (Default)", "Asym < 0.45", "Asym < 0.55"};
    logGraphData(allGraphs, descriptions, centralityLabels, ptCenters);
    
    for (int i = 0; i < ptCenters.size(); ++i) {
        corrected_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - .075, data2.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_3->SetPoint(i, ptCenters[i] + .075, data3.corrected_v2_0_20[i]);
        
        corrected_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - .075, data2.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_3->SetPoint(i, ptCenters[i] + .075, data3.corrected_v2_20_40[i]);
        
        corrected_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - .075, data2.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_3->SetPoint(i, ptCenters[i] + .075, data3.corrected_v2_40_60[i]);
    }
  
    //plot asymmetry variations v2 overlays for each centrality
    auto createGraph_AsymVariations = [&data1, &data2, &data3](TCanvas* canvas, TGraphErrors* graph1, TGraphErrors* graph2, TGraphErrors* graph3, const std::string& legendTitle) {
        graph1->Draw("AP");
        graph1->GetXaxis()->SetLimits(2.0, 5.0);
        graph2->Draw("P SAME");
        graph3->Draw("P SAME");
        graph2->GetXaxis()->SetLimits(2.0, 5.0);
        graph3->GetXaxis()->SetLimits(2.0, 5.0);
        graph1->GetXaxis()->SetTitle("p_{T} [GeV]");
        graph1->GetYaxis()->SetTitle("v_{2}^{#pi^{0}}");
        graph1->SetMinimum(minYaxis);
        graph1->SetMaximum(maxYaxis);
        TLegend *legend = new TLegend(0.2, 0.18, 0.4, 0.33);
        legend->SetBorderSize(0);
        legend->SetTextSize(0.032);
        legend->AddEntry(graph2, "Asymmetry < 0.45", "pe");
        legend->AddEntry(graph1, "Asymmetry < 0.5 (Default)", "pe");
        legend->AddEntry(graph3, "Asymmetry < 0.55", "pe");
        legend->Draw();
        DrawZeroLine(canvas);
        Create_sPHENIX_legend(canvas, 0.14, .72, 0.34, .92, legendTitle.c_str(), 0.045);
    };
    TCanvas *c_Overlay_0_20_AsymmetryCutVariation = new TCanvas("c_Overlay_0_20_AsymmetryCutVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    createGraph_AsymVariations(c_Overlay_0_20_AsymmetryCutVariation, corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, corrected_v2_0_20_graph_3, "0-20% Centrality");
    c_Overlay_0_20_AsymmetryCutVariation->Modified();
    c_Overlay_0_20_AsymmetryCutVariation->Update();
    c_Overlay_0_20_AsymmetryCutVariation->SaveAs((baseDataPath_AsymmetryCutVariations + "Overlay_0_20_v2_AsymVariation.png").c_str());
    
    TCanvas *c_Overlay_20_40_AsymmetryCutVariation = new TCanvas("c_Overlay_20_40_AsymmetryCutVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 20-40% Centrality", 800, 600);
    createGraph_AsymVariations(c_Overlay_20_40_AsymmetryCutVariation, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, corrected_v2_20_40_graph_3, "20-40% Centrality");
    c_Overlay_20_40_AsymmetryCutVariation->Modified();
    c_Overlay_20_40_AsymmetryCutVariation->Update();
    c_Overlay_20_40_AsymmetryCutVariation->SaveAs((baseDataPath_AsymmetryCutVariations + "Overlay_20_40_v2_AsymVariation.png").c_str());
    
    TCanvas *c_Overlay_40_60_AsymmetryCutVariation = new TCanvas("c_Overlay_40_60_AsymmetryCutVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createGraph_AsymVariations(c_Overlay_40_60_AsymmetryCutVariation, corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, corrected_v2_40_60_graph_3, "40-60% Centrality");
    c_Overlay_40_60_AsymmetryCutVariation->Modified();
    c_Overlay_40_60_AsymmetryCutVariation->Update();
    c_Overlay_40_60_AsymmetryCutVariation->SaveAs((baseDataPath_AsymmetryCutVariations + "Overlay_40_60_v2_AsymVariation.png").c_str());
}

void plot_sigBgCorr_and_bgWindowVariations(const Data& data1){
    std::array<GraphProperties, 4> properties = {
        {{kBlack, 20, 1.0}, {kBlue, 20, 1.0}, {kBlue, 20, 1.0}, {kOrange+2, 20, 1.0}}
    };
    /*
     Reference Data Set
     */
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    /*
     For Varied Sideband Calculation with 0.4 Upper Bound -- Default is set at 0.5 GeV
     */
    TGraphErrors* corrected_v2_0_20_graph_1_type4 = CreateGraph(ptCenters, data1.corrected_v2_0_20_type4, data1.corrected_v2_0_20_Errors_type4);
    TGraphErrors* corrected_v2_20_40_graph_1_type4 = CreateGraph(ptCenters, data1.corrected_v2_20_40_type4, data1.corrected_v2_20_40_Errors_type4);
    TGraphErrors* corrected_v2_40_60_graph_1_type4 = CreateGraph(ptCenters, data1.corrected_v2_40_60_type4, data1.corrected_v2_40_60_Errors_type4);
    
    /*
     Measured v2
     */
    TGraphErrors* signal_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.signal_v2_0_20, data1.signal_v2_0_20_Errors);
    TGraphErrors* signal_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.signal_v2_20_40, data1.signal_v2_20_40_Errors);
    TGraphErrors* signal_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.signal_v2_40_60, data1.signal_v2_40_60_Errors);
    
    /*
     Background v2
     */
    TGraphErrors* bg_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.bg_v2_0_20, data1.bg_v2_0_20_Errors);
    TGraphErrors* bg_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.bg_v2_20_40, data1.bg_v2_20_40_Errors);
    TGraphErrors* bg_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.bg_v2_40_60, data1.bg_v2_40_60_Errors);
    
    std::array<std::array<TGraphErrors*, 4>, 3> allGraphs = {{
        {corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_1_type4, bg_v2_0_20_graph_1, signal_v2_0_20_graph_1},
        {corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_1_type4, bg_v2_20_40_graph_1, signal_v2_20_40_graph_1},
        {corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_1_type4, bg_v2_40_60_graph_1, signal_v2_40_60_graph_1}
    }};
    
    for (auto& graphGroup : allGraphs) {
        for (int i = 0; i < graphGroup.size(); ++i) {
            TGraph* graph = graphGroup[i];
            const auto& prop = properties[i];
            setGraphProperties(graph, prop.markerColor, prop.markerColor, prop.markerSize, prop.markerStyle);
        }
    }
    std::vector<std::string> descriptions = {"Default Corrected v2", "Background Window to 0.4 GeV", "Default BG v2", "Default Signal v2"};
    logGraphData(allGraphs, descriptions, centralityLabels, ptCenters);
    
    for (int i = 0; i < ptCenters.size(); ++i) {
        corrected_v2_0_20_graph_1_type4->SetPoint(i, ptCenters[i] - offset, data1.corrected_v2_0_20_type4[i]);
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + offset, data1.corrected_v2_0_20[i]);
        
        corrected_v2_20_40_graph_1_type4->SetPoint(i, ptCenters[i] - offset, data1.corrected_v2_20_40_type4[i]);
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + offset, data1.corrected_v2_20_40[i]);
        
        corrected_v2_40_60_graph_1_type4->SetPoint(i, ptCenters[i] - offset, data1.corrected_v2_40_60_type4[i]);
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + offset, data1.corrected_v2_40_60[i]);
        
        signal_v2_0_20_graph_1->SetPoint(i, ptCenters[i] - 2.0 * offset, data1.signal_v2_0_20[i]);
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + 2.0 * offset, data1.corrected_v2_0_20[i]);
        
        signal_v2_20_40_graph_1->SetPoint(i, ptCenters[i] - 2.0 * offset, data1.signal_v2_20_40[i]);
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + 2.0 * offset, data1.corrected_v2_20_40[i]);
        
        signal_v2_40_60_graph_1->SetPoint(i, ptCenters[i] - 2.0 * offset, data1.signal_v2_40_60[i]);
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + 2.0 * offset, data1.corrected_v2_40_60[i]);
    }
    
    /*
     Plot Background Window Variations
     */
    //0-20%
    TCanvas *c_Overlay_0_20_bgWindowVariation = new TCanvas("c_Overlay_0_20_bgWindowVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_bgWindowVariation, corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_1_type4, "Sideband = [#mu + 3#sigma, 0.4] GeV", "Sideband = [#mu + 3#sigma, 0.5] GeV (Default)", 0.2, 0.18, 0.4, 0.33, "0-20% Centrality");
    c_Overlay_0_20_bgWindowVariation->Modified();
    c_Overlay_0_20_bgWindowVariation->Update();
    c_Overlay_0_20_bgWindowVariation->SaveAs((baseDataPath_BackgroundWindowVariations + "Overlay_0_20_v2_BackgroundWindowVariations.png").c_str());
    
    
    //20-40%
    TCanvas *c_Overlay_20_40_bgWindowVariation = new TCanvas("c_Overlay_20_40_bgWindowVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_20_40_bgWindowVariation, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_1_type4, "Sideband = [#mu + 3#sigma, 0.4] GeV", "Sideband = [#mu + 3#sigma, 0.5] GeV (Default)", 0.2, 0.18, 0.4, 0.33, "20-40% Centrality");
    c_Overlay_20_40_bgWindowVariation->Modified();
    c_Overlay_20_40_bgWindowVariation->Update();
    c_Overlay_20_40_bgWindowVariation->SaveAs((baseDataPath_BackgroundWindowVariations + "Overlay_20_40_v2_BackgroundWindowVariations.png").c_str());
    
    
    //40-60%
    TCanvas *c_Overlay_40_60_bgWindowVariation = new TCanvas("c_Overlay_40_60_bgWindowVariation", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_40_60_bgWindowVariation, corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_1_type4, "Sideband = [#mu + 3#sigma, 0.4] GeV", "Sideband = [#mu + 3#sigma, 0.5] GeV (Default)", 0.2, 0.18, 0.4, 0.33, "40-60% Centrality");
    c_Overlay_40_60_bgWindowVariation->Modified();
    c_Overlay_40_60_bgWindowVariation->Update();
    c_Overlay_40_60_bgWindowVariation->SaveAs((baseDataPath_BackgroundWindowVariations + "Overlay_40_60_v2_BackgroundWindowVariations.png").c_str());
    
    
    auto createGraph_sig_bg_corr = [](TCanvas* canvas, TGraphErrors* graph1, TGraphErrors* graph2, TGraphErrors* graph3, const std::string& legendTitle) {
        graph2->Draw("AP");
        graph2->GetXaxis()->SetTitle("p_{T} [GeV]");
        graph2->GetYaxis()->SetTitle("v_{2}");
        graph1 -> Draw("P SAME");
        graph3 -> Draw("P SAME");
        graph2->SetMinimum(minYaxis);
        graph2->SetMaximum(maxYaxis);
        TLegend *legend = new TLegend(0.2, 0.19, 0.4, 0.39);
        legend->SetBorderSize(0);
        legend->SetTextSize(0.032);
        legend->AddEntry(graph1, "#it{v}_{2}^{measured}", "pe");
        legend->AddEntry(graph2, "#it{v}_{2}^{background}", "pe");
        legend->AddEntry(graph3, "#it{v}_{2}^{#pi^{0}}", "pe");
        legend->Draw();
        Create_sPHENIX_legend(canvas, 0.14,.78,0.34,.93, legendTitle.c_str(), 0.04);
        DrawZeroLine(canvas);
    };
    
    /*
     Plot Signal, Background Corrected v2 Overlay with Default Data
     */
    //0-20%
    TCanvas *c_Overlay_bg_sig_corrOverlay_0_20 = new TCanvas("c_Overlay_bg_sig_corrOverlay_0_20", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    createGraph_sig_bg_corr(c_Overlay_bg_sig_corrOverlay_0_20, signal_v2_0_20_graph_1, bg_v2_0_20_graph_1, corrected_v2_0_20_graph_1, "0-20% Centrality");
    c_Overlay_bg_sig_corrOverlay_0_20->Modified();
    c_Overlay_bg_sig_corrOverlay_0_20->Update();
    c_Overlay_bg_sig_corrOverlay_0_20->SaveAs((BasePlotOutputPath + "/v2_FinalResults/Overlay_0_20_v2_Signal_Back_Correct.png").c_str());
    
    //20-40
    TCanvas *c_Overlay_bg_sig_corrOverlay_20_40 = new TCanvas("c_Overlay_bg_sig_corrOverlay_20_40", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    createGraph_sig_bg_corr(c_Overlay_bg_sig_corrOverlay_20_40, signal_v2_20_40_graph_1, bg_v2_20_40_graph_1, corrected_v2_20_40_graph_1, "20-40% Centrality");
    c_Overlay_bg_sig_corrOverlay_20_40->Modified();
    c_Overlay_bg_sig_corrOverlay_20_40->Update();
    c_Overlay_bg_sig_corrOverlay_20_40->SaveAs((BasePlotOutputPath + "/v2_FinalResults/Overlay_20_40_v2_Signal_Back_Correct.png").c_str());
    
    //40-60
    TCanvas *c_Overlay_bg_sig_corrOverlay_40_60 = new TCanvas("c_Overlay_bg_sig_corrOverlay_40_60", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 0-20% Centrality", 800, 600);
    createGraph_sig_bg_corr(c_Overlay_bg_sig_corrOverlay_40_60, signal_v2_40_60_graph_1, bg_v2_40_60_graph_1, corrected_v2_40_60_graph_1, "40-60% Centrality");
    c_Overlay_bg_sig_corrOverlay_40_60->Modified();
    c_Overlay_bg_sig_corrOverlay_40_60->Update();
    c_Overlay_bg_sig_corrOverlay_40_60->SaveAs((BasePlotOutputPath + "/v2_FinalResults/Overlay_40_60_v2_Signal_Back_Correct.png").c_str());
}


void plotProduction_Comparisons(const Data& data1, Data& data2) {
    std::array<GraphProperties, 6> properties = {
        {{kBlack, 20, 1.0}, {kBlue, 20, 1.0}, {kBlack, 20, 1.0}, {kBlue, 20, 1.0}, {kBlack, 20, 1.0}, {kBlue, 20, 1.0}}
      };
    TGraphErrors* corrected_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_0_20, data1.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_20_40, data1.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.corrected_v2_40_60, data1.corrected_v2_40_60_Errors);
    
    TGraphErrors* corrected_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_0_20, data2.corrected_v2_0_20_Errors);
    TGraphErrors* corrected_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_20_40, data2.corrected_v2_20_40_Errors);
    TGraphErrors* corrected_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.corrected_v2_40_60, data2.corrected_v2_40_60_Errors);

    TGraphErrors* signal_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.signal_v2_0_20, data1.signal_v2_0_20_Errors);
    TGraphErrors* signal_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.signal_v2_20_40, data1.signal_v2_20_40_Errors);
    TGraphErrors* signal_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.signal_v2_40_60, data1.signal_v2_40_60_Errors);
    
    TGraphErrors* signal_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.signal_v2_0_20, data2.signal_v2_0_20_Errors);
    TGraphErrors* signal_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.signal_v2_20_40, data2.signal_v2_20_40_Errors);
    TGraphErrors* signal_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.signal_v2_40_60, data2.signal_v2_40_60_Errors);

    TGraphErrors* bg_v2_0_20_graph_1 = CreateGraph(ptCenters, data1.bg_v2_0_20, data1.bg_v2_0_20_Errors);
    TGraphErrors* bg_v2_20_40_graph_1 = CreateGraph(ptCenters, data1.bg_v2_20_40, data1.bg_v2_20_40_Errors);
    TGraphErrors* bg_v2_40_60_graph_1 = CreateGraph(ptCenters, data1.bg_v2_40_60, data1.bg_v2_40_60_Errors);
    
    TGraphErrors* bg_v2_0_20_graph_2 = CreateGraph(ptCenters, data2.bg_v2_0_20, data2.bg_v2_0_20_Errors);
    TGraphErrors* bg_v2_20_40_graph_2 = CreateGraph(ptCenters, data2.bg_v2_20_40, data2.bg_v2_20_40_Errors);
    TGraphErrors* bg_v2_40_60_graph_2 = CreateGraph(ptCenters, data2.bg_v2_40_60, data2.bg_v2_40_60_Errors);
    
      
    std::array<std::array<TGraphErrors*, 6>, 3> allGraphs = {{
      {corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, signal_v2_0_20_graph_1, signal_v2_0_20_graph_2, bg_v2_0_20_graph_1, bg_v2_0_20_graph_2},
      {corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, signal_v2_20_40_graph_1, signal_v2_20_40_graph_2, bg_v2_20_40_graph_1, bg_v2_20_40_graph_2},
      {corrected_v2_40_60_graph_1, corrected_v2_40_60_graph_2, signal_v2_40_60_graph_1, signal_v2_40_60_graph_2, bg_v2_40_60_graph_1, bg_v2_40_60_graph_2}
    }};
      
    for (auto& graphGroup : allGraphs) {
      for (int i = 0; i < graphGroup.size(); ++i) {
          TGraph* graph = graphGroup[i];
          const auto& prop = properties[i];
          setGraphProperties(graph, prop.markerColor, prop.markerColor, prop.markerSize, prop.markerStyle);
      }
    }
    
    std::vector<std::string> descriptions = {"p015 Corrected v2", "p013 Corrected v2", "p015 Measured v2", "p013 Measured v2", "p015 BG v2", "p013 BG v2"};
    logGraphData(allGraphs, descriptions, centralityLabels, ptCenters);
    
    for (int i = 0; i < ptCenters.size(); ++i) {
        corrected_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_0_20[i]);
        corrected_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_0_20[i]);
        
        corrected_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_20_40[i]);
        corrected_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_20_40[i]);
        
        corrected_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - .05, data2.corrected_v2_40_60[i]);
        corrected_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + .05, data1.corrected_v2_40_60[i]);
        
        signal_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - .05, data2.signal_v2_0_20[i]);
        signal_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + .05, data1.signal_v2_0_20[i]);
        
        signal_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - .05, data2.signal_v2_20_40[i]);
        signal_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + .05, data1.signal_v2_20_40[i]);
        
        signal_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - .05, data2.signal_v2_40_60[i]);
        signal_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + .05, data1.signal_v2_40_60[i]);
        
        bg_v2_0_20_graph_2->SetPoint(i, ptCenters[i] - .05, data2.bg_v2_0_20[i]);
        bg_v2_0_20_graph_1->SetPoint(i, ptCenters[i] + .05, data1.bg_v2_0_20[i]);
        
        bg_v2_20_40_graph_2->SetPoint(i, ptCenters[i] - .05, data2.bg_v2_20_40[i]);
        bg_v2_20_40_graph_1->SetPoint(i, ptCenters[i] + .05, data1.bg_v2_20_40[i]);
        
        bg_v2_40_60_graph_2->SetPoint(i, ptCenters[i] - .05, data2.bg_v2_40_60[i]);
        bg_v2_40_60_graph_1->SetPoint(i, ptCenters[i] + .05, data1.bg_v2_40_60[i]);
    }
    
    /*
     Overlay p013, p015 corrected v2
     */
    TCanvas *c_Overlay_0_20_productionComparisons_corrected = new TCanvas("c_Overlay_0_20_productionComparisons_corrected", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_productionComparisons_corrected, corrected_v2_0_20_graph_1, corrected_v2_0_20_graph_2, "p013 v_{2}^{#pi^{0}}", "p015 v_{2}^{#pi^{0}}", 0.2, 0.18, 0.4, 0.33, "0-20% Centrality");
    c_Overlay_0_20_productionComparisons_corrected->Modified();
    c_Overlay_0_20_productionComparisons_corrected->Update();
    c_Overlay_0_20_productionComparisons_corrected->SaveAs((baseDataPath_ProductionComparisons + "Overlay_0_20_v2_p013_p015_correctedV2Comparison.png").c_str());
    
    TCanvas *c_Overlay_20_40_productionComparisons_corrected = new TCanvas("c_Overlay_20_40_productionComparisons_corrected", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_productionComparisons_corrected, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, "p013 v_{2}^{#pi^{0}}", "p015 v_{2}^{#pi^{0}}", 0.2, 0.18, 0.4, 0.33, "20-40% Centrality");
    c_Overlay_20_40_productionComparisons_corrected->Modified();
    c_Overlay_20_40_productionComparisons_corrected->Update();
    c_Overlay_20_40_productionComparisons_corrected->SaveAs((baseDataPath_ProductionComparisons + "Overlay_20_40_v2_p013_p015_correctedV2Comparison.png").c_str());
    
    TCanvas *c_Overlay_40_60_productionComparisons_corrected = new TCanvas("c_Overlay_40_60_productionComparisons_corrected", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_productionComparisons_corrected, corrected_v2_20_40_graph_1, corrected_v2_20_40_graph_2, "p013 v_{2}^{#pi^{0}}", "p015 v_{2}^{#pi^{0}}", 0.2, 0.18, 0.4, 0.33, "40-60% Centrality");
    c_Overlay_40_60_productionComparisons_corrected->Modified();
    c_Overlay_40_60_productionComparisons_corrected->Update();
    c_Overlay_40_60_productionComparisons_corrected->SaveAs((baseDataPath_ProductionComparisons + "Overlay_40_60_v2_p013_p015_correctedV2Comparison.png").c_str());
    
    /*
     Overlay p013, p015 signal v2
     */
    TCanvas *c_Overlay_0_20_productionComparisons_signal = new TCanvas("c_Overlay_0_20_productionComparisons_signal", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_productionComparisons_signal, signal_v2_0_20_graph_1, signal_v2_0_20_graph_2, "p013 v_{2}^{measured}", "p015 v_{2}^{measured}", 0.2, 0.18, 0.4, 0.33, "0-20% Centrality");
    c_Overlay_0_20_productionComparisons_signal->Modified();
    c_Overlay_0_20_productionComparisons_signal->Update();
    c_Overlay_0_20_productionComparisons_signal->SaveAs((baseDataPath_ProductionComparisons + "Overlay_0_20_v2_p013_p015_signalV2Comparison.png").c_str());
    
    TCanvas *c_Overlay_20_40_productionComparisons_signal = new TCanvas("c_Overlay_20_40_productionComparisons_signal", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_20_40_productionComparisons_signal, signal_v2_20_40_graph_1, signal_v2_20_40_graph_2, "p013 v_{2}^{measured}", "p015 v_{2}^{measured}", 0.2, 0.18, 0.4, 0.33, "20-40% Centrality");
    c_Overlay_20_40_productionComparisons_signal->Modified();
    c_Overlay_20_40_productionComparisons_signal->Update();
    c_Overlay_20_40_productionComparisons_signal->SaveAs((baseDataPath_ProductionComparisons + "Overlay_20_40_v2_p013_p015_signalV2Comparison.png").c_str());
    
    TCanvas *c_Overlay_40_60_productionComparisons_signal = new TCanvas("c_Overlay_40_60_productionComparisons_signal", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_40_60_productionComparisons_signal, signal_v2_40_60_graph_1, signal_v2_40_60_graph_2, "p013 v_{2}^{measured}", "p015 v_{2}^{measured}", 0.2, 0.18, 0.4, 0.33, "40-60% Centrality");
    c_Overlay_40_60_productionComparisons_signal->Modified();
    c_Overlay_40_60_productionComparisons_signal->Update();
    c_Overlay_40_60_productionComparisons_signal->SaveAs((baseDataPath_ProductionComparisons + "Overlay_40_60_v2_p013_p015_signalV2Comparison.png").c_str());
    
    /*
     Overlay p013, p015 bg v2
     */
    TCanvas *c_Overlay_0_20_productionComparisons_bg = new TCanvas("c_Overlay_0_20_productionComparisons_bg", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_0_20_productionComparisons_bg, bg_v2_0_20_graph_1, bg_v2_0_20_graph_2, "p013 v_{2}^{BG}", "p015 v_{2}^{BG}", 0.2, 0.18, 0.4, 0.33, "0-20% Centrality");
    c_Overlay_0_20_productionComparisons_bg->Modified();
    c_Overlay_0_20_productionComparisons_bg->Update();
    c_Overlay_0_20_productionComparisons_bg->SaveAs((baseDataPath_ProductionComparisons + "Overlay_0_20_v2_p013_p015_bgV2Comparison.png").c_str());
    
    TCanvas *c_Overlay_20_40_productionComparisons_bg = new TCanvas("c_Overlay_20_40_productionComparisons_bg", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_20_40_productionComparisons_bg, bg_v2_20_40_graph_1, bg_v2_20_40_graph_2, "p013 v_{2}^{BG}", "p015 v_{2}^{BG}", 0.2, 0.18, 0.4, 0.33, "20-40% Centrality");
    c_Overlay_20_40_productionComparisons_bg->Modified();
    c_Overlay_20_40_productionComparisons_bg->Update();
    c_Overlay_20_40_productionComparisons_bg->SaveAs((baseDataPath_ProductionComparisons + "Overlay_20_40_v2_p013_p015_bgV2Comparison.png").c_str());
    
    TCanvas *c_Overlay_40_60_productionComparisons_bg = new TCanvas("c_Overlay_40_60_productionComparisons_bg", "#pi^{0} #it{v}_{2} vs #it{p}_{T} 40-60% Centrality", 800, 600);
    createAndDraw_2graphEntries(c_Overlay_40_60_productionComparisons_bg, bg_v2_40_60_graph_1, bg_v2_40_60_graph_2, "p013 v_{2}^{BG}", "p015 v_{2}^{BG}", 0.2, 0.18, 0.4, 0.33, "40-60% Centrality");
    c_Overlay_40_60_productionComparisons_bg->Modified();
    c_Overlay_40_60_productionComparisons_bg->Update();
    c_Overlay_40_60_productionComparisons_bg->SaveAs((baseDataPath_ProductionComparisons + "Overlay_40_60_v2_p013_p015_bgV2Comparison.png").c_str());
}
void initializePaths() {
    std::cout << "Please enter the user path: ";
    std::getline(std::cin, userPath);  // Get user input for the path
    
    BasePlotOutputPath = userPath + "/p015";
    BaseCSVoutput = BasePlotOutputPath + "/vN-CSV-files";
    ReferenceData = BaseCSVoutput + "/vn-p015.csv";

    //Extraneous CSV files for plot output
    phenixFilePath = userPath + "/FinalCleanedPhenix.csv"; //path to cleaned PHENIX data
    baseDataPath_ProductionComparisons = BasePlotOutputPath + "/ProductionComparisons/";
    p013_filePath = userPath + "/Default_Final_v2_p013.csv"; //for production comparison


    //paths to data sets for Systematics Calculation and other comparsions
    //EMCal Scale Variations
    filePathEMCal_Syst_SYST1CEMC = BaseCSVoutput + "/vn-SYST1CEMC.csv";
    filePathEMCal_Syst_SYST2CEMC = BaseCSVoutput + "/vn-SYST2CEMC.csv";
    filePathEMCal_Syst_SYST3DCEMC = BaseCSVoutput + "/vn-SYST3DCEMC.csv";
    filePathEMCal_Syst_SYST3UCEMC = BaseCSVoutput + "/vn-SYST3UCEMC.csv";
    filePathEMCal_Syst_SYST4CEMC = BaseCSVoutput + "/vn-SYST4CEMC.csv";
    filePath_AsymmetryVariations_45 = BaseCSVoutput + "/vn-asym-0.45.csv";
    filePath_AsymmetryVariations_55 = BaseCSVoutput + "/vn-asym-0.55.csv";
    filePathSampleSizeVariation = BaseCSVoutput + "/vn-samples-25.csv";
    filePathSignal_Bound_Variation = BaseCSVoutput + "/vn-sigma-1.5.csv"; //varied signal window
    //note background window variation is embedded in Default v2 CSV file

    //output folders for systematics plots and v2 comparisons
    SystematicsBasePlotOutput = BasePlotOutputPath + "/Systematics_Analysis-v2-Checks/";
    baseDataPath_EmCal_Systematics = SystematicsBasePlotOutput + "EMCal_systematics/";
    baseDataPath_AsymmetryCutVariations = SystematicsBasePlotOutput + "AsymmetryCutVariations/";
    baseDataPath_SampleSizeVariations = SystematicsBasePlotOutput + "SampleSize_Variation/";
    baseDataPath_SignalWindowVariations = SystematicsBasePlotOutput + "SignalWindow_Variations/";
    baseDataPath_BackgroundWindowVariations = SystematicsBasePlotOutput + "BackgroundWindow_Variations/";
}
void FinalizeResults() {
    initializePaths();
    gROOT->LoadMacro("sPhenixStyle.C");
    SetsPhenixStyle();
    
    Data defaultData, data_SYST1CEMC, data_SYST2CEMC, data_SYST3DCEMC, data_SYST3UCEMC, data_SYST4CEMC, data_Signal_Bound_Variation;
    
    // Read the default data set
    Read_DataSet(ReferenceData, defaultData);
    // Read v2 values from each EMCal scale variation
    Read_DataSet(filePathEMCal_Syst_SYST1CEMC, data_SYST1CEMC);
    Read_DataSet(filePathEMCal_Syst_SYST2CEMC, data_SYST2CEMC);
    Read_DataSet(filePathEMCal_Syst_SYST3DCEMC, data_SYST3DCEMC);
    Read_DataSet(filePathEMCal_Syst_SYST3UCEMC, data_SYST3UCEMC);
    Read_DataSet(filePathEMCal_Syst_SYST4CEMC, data_SYST4CEMC);
    std::vector<Data> emCalDataSets = {defaultData, data_SYST1CEMC, data_SYST2CEMC, data_SYST3DCEMC, data_SYST3UCEMC, data_SYST4CEMC};
    
    //read in data set for v2 values from signal bound variation
    Read_DataSet(filePathSignal_Bound_Variation, data_Signal_Bound_Variation);
    //write and read path for CSV of EMCal scale contributors
    std::string statUncertaintyFilePath_EMCal_Contributors = baseDataPath_EmCal_Systematics + "StatUncertaintyTable_EMCalVariationsOnly.csv";
    //write and read path for CSV of total syst contributors and calculation
    std::string statUncertaintyFilePath = SystematicsBasePlotOutput + "StatUncertaintyTable_p015.csv";
    
    WriteComparisonTo_EMcalScale_CSV(emCalDataSets, defaultData, statUncertaintyFilePath_EMCal_Contributors); //calculate EMCal scale contributors and quadarture sum
    WriteComparisonToCSV(emCalDataSets, data_Signal_Bound_Variation, defaultData, statUncertaintyFilePath); //calculate total systematic uncertainty
     
    ReadStatUncertainties(statUncertaintyFilePath, defaultData); //read total systematic uncertainty CSV

    plotting_Results_andPHENIXoverlay(defaultData); //plot final results and PHENIX overlay
    plotting_Systematics(defaultData); //plot total systematic contributions
    
    EMCal_Systematic_Data EMCal_Systematic_data1;
    ReadStatUncertainties_emCalScaleCSV(statUncertaintyFilePath_EMCal_Contributors, EMCal_Systematic_data1); //read EMCal Scale Syst Contributors
    plotting_EMCal_Syst_Contributors(EMCal_Systematic_data1); //plot the above
    
    PlotConfig config = initializePlotConfig(); //use booleans at top of macro to decide if want to plot v2 overlays wether or not CSV produced

    Data dataP013, dataAsymLow, dataAsymHigh, data_SampleSizeVariation;

    if (config.plotSignalWindowVariations) {
        plot_SignalWindow_Variation(defaultData, data_Signal_Bound_Variation);
    }
    if (config.plotEMCalScaleVariations) {
        plot_EMCal_Scale_v2_overlays(defaultData, data_SYST1CEMC, data_SYST2CEMC, data_SYST3DCEMC, data_SYST3UCEMC, data_SYST4CEMC);
    }
    if (config.plotAsymmetryCutVariations) {
        Read_DataSet(filePath_AsymmetryVariations_45, dataAsymLow);
        Read_DataSet(filePath_AsymmetryVariations_55, dataAsymHigh);

        plot_AsymmetryCut_Variations(defaultData, dataAsymLow, dataAsymHigh);
    }
    if (config.plotSampleSizeVariations) {
        Read_DataSet(filePathSampleSizeVariation, data_SampleSizeVariation);
        plot_SampleSize_Variations(defaultData, data_SampleSizeVariation);
    }
    if (config.plotSigBgCorrAnd_bgWindowVariations) {
        plot_sigBgCorr_and_bgWindowVariations(defaultData);
    }
    if (config.plotProduction_Comparisons) {
        Read_DataSet(p013_filePath, dataP013);
        plotProduction_Comparisons(defaultData, dataP013);
    }
}
